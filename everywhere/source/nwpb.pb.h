// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nwpb.proto

#ifndef PROTOBUF_nwpb_2eproto__INCLUDED
#define PROTOBUF_nwpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_nwpb_2eproto();
void protobuf_AssignDesc_nwpb_2eproto();
void protobuf_ShutdownFile_nwpb_2eproto();

class NWPb;
class Request;
class Response;
class Notify;
class LoginRqst;
class LoginRsps;
class ChangePasswordRqst;
class HeartbeatRqst;
class HeartbeatRsps;
class RegisterRqst;
class RegisterRsps;
class GetNWInfoRqst;
class GetNWInfoRsps;
class SetAutoParamRqst;
class GetAutoParamRsps;
class SetConfigRqst;
class GetConfigRqst;
class GetConfigRsps;
class QueryLogRqst;
class NWLog;
class QueryLogRsps;
class TimeSynchRqst;
class RebootRqst;
class GetNodeListRqst;
class GetNodeListRsps;
class NodeEntry;
class GetNodeStatusRqst;
class GetNodeStatusRsps;
class GetTopologyRsps;
class Node;
class ParentNode;
class SubscribeNotificationNtf;
class DeviceBindingRqst;
class RmDeviceBindingRqst;
class RequestNodeDataUploadNtf;
class SensorData;
class NmpDataUploadNtf;
class ContinueNtf;
class GetNodeRealDataRqst;
class GetNodeRealDataRsps;
class SetCommandToNodeRqst;
class TypeData;
class SensorTypeData;
class GetNodeSettingsRqst;
class GetNodeSettingsRsps;
class GetUpDisconCachedAlarmRqst;
class GetUpDisconCachedAlarmRsps;
class CachedAlarmData;
class SubscribeAllNodeDataRqst;
class CancelAllNodeDataRqst;
class BatSubscribeNodeDataRqst;
class BatCancelNodeDataRqst;
class BlackWhiteNodeRqst;
class GetBlackWhiteRqst;
class GetBlackWhiteRsps;
class DownloadFirmwareRqst;
class DownloadFirmwareRsps;
class DownloadFirmwareNtf;
class UpgradeModuleRqst;
class UpgradeModuleRsps;
class UpgradeModuleNtf;
class TerminalPort;
class TerminalStatus;
class GetTerminalStatusRqst;
class GetTerminalStatusRsps;
class TerminalCmd;
class SetTerminalCtrlCmdRqst;

enum Response_Error {
  Response_Error_NWPB_ERROR_OK = 200,
  Response_Error_NWPB_ERROR_DECRYPT_FAILED = 421,
  Response_Error_NWPB_ERROR_USER_PASSWORD_INVALID = 422,
  Response_Error_NWPB_ERROR_USER_INVALID_STATUS = 423,
  Response_Error_NWPB_ERROR_USER_NOT_EXIST = 424,
  Response_Error_NWPB_ERROR_USER_NOT_LOGIN = 425,
  Response_Error_NWPB_ERROR_UNSUPPORT_SUBSCRIBE_TYPE = 426,
  Response_Error_NWPB_ERROR_INVALID_TIME_VALUE = 427,
  Response_Error_NWPB_ERROR_UNSUPPORT_NODELIST_GET_TYPE = 428,
  Response_Error_NWPB_ERROR_UNSUPPORT_ENCRYPT_TYPE = 429,
  Response_Error_NWPB_ERROR_NODE_UNSUPPORT_COMMAND = 430,
  Response_Error_NWPB_ERROR_INVALID_SENSOR_NO = 431,
  Response_Error_NWPB_ERROR_INVALID_NODE_ID = 432,
  Response_Error_NWPB_ERROR_NONE_THRESHOLD_DATA = 433,
  Response_Error_NWPB_ERROR_USER_ALREADY_EXIST = 434,
  Response_Error_NWPB_ERROR_WRONG_OLD_PASSWORD = 435,
  Response_Error_NWPB_ERROR_USER_ALREADY_LOGOUT = 436,
  Response_Error_NWPB_ERROR_INVALID_PROTOCOL_VERSION = 437,
  Response_Error_NWPB_ERROR_INVALID_BW_CONFIG_TYPE = 438,
  Response_Error_NWPB_ERROR_INVALID_BW_CONFIG_COMMAND = 439,
  Response_Error_NWPB_ERROR_USER_DELETE_FORBIDDEN = 440,
  Response_Error_NWPB_ERROR_UNSUPPORT_CONFIG_NAME = 441,
  Response_Error_NWPB_ERROR_UNSUPPORT_COMMON_CMD = 442,
  Response_Error_NWPB_ERROR_USERNAME_NULL = 443,
  Response_Error_NWPB_ERROR_SENSOR_NOT_EXIST = 444,
  Response_Error_NWPB_ERROR_INVALID_SEND_INTERVAL = 445,
  Response_Error_NWPB_ERROR_ZERO_SEND_INTERVAL = 446,
  Response_Error_NWPB_ERROR_INVALID_INPUT_PARAM = 447,
  Response_Error_NWPB_ERROR_SEND_INTERVAL_TOO_SHORT = 448,
  Response_Error_NWPB_ERROR_SEND_INTERVAL_TOO_LONG = 449,
  Response_Error_NWPB_ERROR_INVALID_NW_ID = 450,
  Response_Error_NWPB_ERROR_SESSION_TIMEOUT = 451,
  Response_Error_NWPB_ERROR_SESSION_NOT_EXIST = 452,
  Response_Error_NWPB_ERROR_NODE_NOT_REGISTER = 453,
  Response_Error_NWPB_ERROR_CHOOSE_LONGER_PASSWORD = 454,
  Response_Error_NWPB_ERROR_TOO_MANY_USERS = 521,
  Response_Error_NWPB_ERROR_KICKOUT = 522,
  Response_Error_NWPB_ERROR_USER_DELETED = 523,
  Response_Error_NWPB_ERROR_MSG_SERVICE_ERROR = 524,
  Response_Error_NWPB_ERROR_WSN_SERVICE_UNAVAILABLE = 525,
  Response_Error_NWPB_ERROR_WSN_SERVICE_ERROR = 526,
  Response_Error_NWPB_ERROR_DB_SERVICE_UNAVAILABLE = 527,
  Response_Error_NWPB_ERROR_DB_SERVICE_ERROR = 528,
  Response_Error_NWPB_ERROR_USER_SERVICE_UNAVAILABLE = 529,
  Response_Error_NWPB_ERROR_USER_SERVICE_ERROR = 530,
  Response_Error_NWPB_ERROR_UNSUPPORT_FUNCTION = 531,
  Response_Error_NWPB_ERROR_WSN_NET_TIMEOUT = 532,
  Response_Error_NWPB_ERROR_WSN_NODE_SENSOR_NOT_READY = 533,
  Response_Error_NWPB_ERROR_SET_COMMAND_IN_PROCESSSING = 534,
  Response_Error_NWPB_ERROR_ONLY_SUPPORT_SET_ONE_THRESHOLD = 535,
  Response_Error_NWPB_ERROR_WSN_NET_OPERATION_FAILED = 536,
  Response_Error_NWPB_ERROR_LOG_XML_ERROR = 537,
  Response_Error_NWPB_ERROR_XML_OPERATION_ERROR = 538,
  Response_Error_NWPB_ERROR_SERVER_LOGIC_ERROR = 539,
  Response_Error_NWPB_ERROR_NODE_OPERATION = 540,
  Response_Error_NWPB_ERROR_WAIT_OTHER_MAIN_OPERATION = 541,
  Response_Error_NWPB_ERROR_MAIN_NODE_FAILED = 542,
  Response_Error_NWPB_ERROR_MAIN_NODE_SET_FAILED = 543,
  Response_Error_NWPB_ERROR_AUTOREG_UNREGISTERING = 544,
  Response_Error_NWPB_ERROR_IPC_SERVICE_ERROR = 545,
  Response_Error_NWPB_ERROR_WAIT_WIFI_CONNECTING = 546,
  Response_Error_NWPB_ERROR_GENERAL_OPERATION_TIMEOUT = 547,
  Response_Error_NWPB_ERROR_VWLITE_CONNECT_FAILED = 548,
  Response_Error_NWPB_ERROR_VWLITE_DISCONNECT = 549,
  Response_Error_NWPB_ERROR_VWLITE_RESPONSE_BAD = 550,
  Response_Error_NWPB_ERROR_DEVICE_BINDING_FAIL = 551,
  Response_Error_NWPB_ERROR_DEVICE_BINDING_NO_VC_ACK = 552,
  Response_Error_NWPB_ERROR_DEVICE_BINDING_NO_GW_ACK = 553,
  Response_Error_NWPB_ERROR_DEVICE_RM_BINDING_FAIL = 554,
  Response_Error_NWPB_ERROR_DEVICE_UNKNOW_ERROR = 555
};
bool Response_Error_IsValid(int value);
const Response_Error Response_Error_Error_MIN = Response_Error_NWPB_ERROR_OK;
const Response_Error Response_Error_Error_MAX = Response_Error_NWPB_ERROR_DEVICE_UNKNOW_ERROR;
const int Response_Error_Error_ARRAYSIZE = Response_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_Error_descriptor();
inline const ::std::string& Response_Error_Name(Response_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_Error_descriptor(), value);
}
inline bool Response_Error_Parse(
    const ::std::string& name, Response_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_Error>(
    Response_Error_descriptor(), name, value);
}
enum SubscribeNotificationNtf_MessageType {
  SubscribeNotificationNtf_MessageType_NODE_STATE_CHANGE = 1,
  SubscribeNotificationNtf_MessageType_MEMORY_CARD_FULL = 2,
  SubscribeNotificationNtf_MessageType_MEMORY_CARD_ANOMALY = 3
};
bool SubscribeNotificationNtf_MessageType_IsValid(int value);
const SubscribeNotificationNtf_MessageType SubscribeNotificationNtf_MessageType_MessageType_MIN = SubscribeNotificationNtf_MessageType_NODE_STATE_CHANGE;
const SubscribeNotificationNtf_MessageType SubscribeNotificationNtf_MessageType_MessageType_MAX = SubscribeNotificationNtf_MessageType_MEMORY_CARD_ANOMALY;
const int SubscribeNotificationNtf_MessageType_MessageType_ARRAYSIZE = SubscribeNotificationNtf_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SubscribeNotificationNtf_MessageType_descriptor();
inline const ::std::string& SubscribeNotificationNtf_MessageType_Name(SubscribeNotificationNtf_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SubscribeNotificationNtf_MessageType_descriptor(), value);
}
inline bool SubscribeNotificationNtf_MessageType_Parse(
    const ::std::string& name, SubscribeNotificationNtf_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubscribeNotificationNtf_MessageType>(
    SubscribeNotificationNtf_MessageType_descriptor(), name, value);
}
enum SetCommandToNodeRqst_Command {
  SetCommandToNodeRqst_Command_ON_OFF = 1,
  SetCommandToNodeRqst_Command_SET_THRESHOLD = 2,
  SetCommandToNodeRqst_Command_SET_INTERVAL = 3,
  SetCommandToNodeRqst_Command_DATA_SWITCH = 4
};
bool SetCommandToNodeRqst_Command_IsValid(int value);
const SetCommandToNodeRqst_Command SetCommandToNodeRqst_Command_Command_MIN = SetCommandToNodeRqst_Command_ON_OFF;
const SetCommandToNodeRqst_Command SetCommandToNodeRqst_Command_Command_MAX = SetCommandToNodeRqst_Command_DATA_SWITCH;
const int SetCommandToNodeRqst_Command_Command_ARRAYSIZE = SetCommandToNodeRqst_Command_Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* SetCommandToNodeRqst_Command_descriptor();
inline const ::std::string& SetCommandToNodeRqst_Command_Name(SetCommandToNodeRqst_Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    SetCommandToNodeRqst_Command_descriptor(), value);
}
inline bool SetCommandToNodeRqst_Command_Parse(
    const ::std::string& name, SetCommandToNodeRqst_Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SetCommandToNodeRqst_Command>(
    SetCommandToNodeRqst_Command_descriptor(), name, value);
}
enum GetNodeSettingsRqst_Command {
  GetNodeSettingsRqst_Command_GET_ON_OFF = 1,
  GetNodeSettingsRqst_Command_GET_THRESHOLD = 2,
  GetNodeSettingsRqst_Command_GET_INTERVAL = 3
};
bool GetNodeSettingsRqst_Command_IsValid(int value);
const GetNodeSettingsRqst_Command GetNodeSettingsRqst_Command_Command_MIN = GetNodeSettingsRqst_Command_GET_ON_OFF;
const GetNodeSettingsRqst_Command GetNodeSettingsRqst_Command_Command_MAX = GetNodeSettingsRqst_Command_GET_INTERVAL;
const int GetNodeSettingsRqst_Command_Command_ARRAYSIZE = GetNodeSettingsRqst_Command_Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* GetNodeSettingsRqst_Command_descriptor();
inline const ::std::string& GetNodeSettingsRqst_Command_Name(GetNodeSettingsRqst_Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    GetNodeSettingsRqst_Command_descriptor(), value);
}
inline bool GetNodeSettingsRqst_Command_Parse(
    const ::std::string& name, GetNodeSettingsRqst_Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetNodeSettingsRqst_Command>(
    GetNodeSettingsRqst_Command_descriptor(), name, value);
}
enum BlackWhiteNodeRqst_Command {
  BlackWhiteNodeRqst_Command_ADD = 1,
  BlackWhiteNodeRqst_Command_DEL = 2
};
bool BlackWhiteNodeRqst_Command_IsValid(int value);
const BlackWhiteNodeRqst_Command BlackWhiteNodeRqst_Command_Command_MIN = BlackWhiteNodeRqst_Command_ADD;
const BlackWhiteNodeRqst_Command BlackWhiteNodeRqst_Command_Command_MAX = BlackWhiteNodeRqst_Command_DEL;
const int BlackWhiteNodeRqst_Command_Command_ARRAYSIZE = BlackWhiteNodeRqst_Command_Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* BlackWhiteNodeRqst_Command_descriptor();
inline const ::std::string& BlackWhiteNodeRqst_Command_Name(BlackWhiteNodeRqst_Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    BlackWhiteNodeRqst_Command_descriptor(), value);
}
inline bool BlackWhiteNodeRqst_Command_Parse(
    const ::std::string& name, BlackWhiteNodeRqst_Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlackWhiteNodeRqst_Command>(
    BlackWhiteNodeRqst_Command_descriptor(), name, value);
}
enum Command {
  LOGIN = 1,
  LOGOUT = 2,
  CHANGE_PASSWORD = 3,
  CHANGE_SESSION_KEY = 4,
  HEARBEAT = 5,
  REGISTER = 6,
  UNREGISTER = 7,
  GET_NWINFO = 8,
  GET_NODE_LIST = 9,
  GET_TOPOLOGY = 10,
  SET_AUTO_PARAM = 11,
  GET_AUTO_PARAM = 12,
  TIME_SYNCH = 13,
  SUBSCRIBE_NOTIFICATION = 14,
  REBOOT = 15,
  GET_CONFIG = 16,
  SET_CONFIG = 17,
  QUERY_LOG = 18,
  BLACK_WHITE_NODE = 19,
  GET_BLACK_WHITE = 20,
  SUBSCRIBE_ALL_NODE_DATA = 21,
  CANCEL_ALL_NODE_DATA = 22,
  BAT_SUBSCRIBE_NODE_DATA = 23,
  BAT_CANCEL_NODE_DATA = 24,
  REQUEST_NODE_DATA_UPLOAD = 25,
  GET_NODE_REALDATA = 26,
  GET_UP_DISCON_CACHED_ALARM = 27,
  GET_NODE_CACHED_DATA = 28,
  SET_COMMAND_TO_NODE = 29,
  GET_NODE_SETTINGS = 30,
  GET_NODE_STATUS = 31,
  NMP_DATA_UPLOAD = 34,
  DEVICE_BINDING = 35,
  GET_TERMINAL_STATUS = 36,
  SET_TERMINAL_CTRL_CMD = 37,
  REMOVE_DEVICE_BINDING = 38,
  DOWNLOAD_FIRMWARE = 32,
  UPGRADE_MODULE = 33,
  CONTINUE = 46
};
bool Command_IsValid(int value);
const Command Command_MIN = LOGIN;
const Command Command_MAX = CONTINUE;
const int Command_ARRAYSIZE = Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_descriptor();
inline const ::std::string& Command_Name(Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_descriptor(), value);
}
inline bool Command_Parse(
    const ::std::string& name, Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command>(
    Command_descriptor(), name, value);
}
enum Encrypt {
  NONE = 1,
  AES_64 = 2,
  AES_128 = 3,
  TEA_16 = 4
};
bool Encrypt_IsValid(int value);
const Encrypt Encrypt_MIN = NONE;
const Encrypt Encrypt_MAX = TEA_16;
const int Encrypt_ARRAYSIZE = Encrypt_MAX + 1;

const ::google::protobuf::EnumDescriptor* Encrypt_descriptor();
inline const ::std::string& Encrypt_Name(Encrypt value) {
  return ::google::protobuf::internal::NameOfEnum(
    Encrypt_descriptor(), value);
}
inline bool Encrypt_Parse(
    const ::std::string& name, Encrypt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Encrypt>(
    Encrypt_descriptor(), name, value);
}
enum DeviceType {
  NW = 1
};
bool DeviceType_IsValid(int value);
const DeviceType DeviceType_MIN = NW;
const DeviceType DeviceType_MAX = NW;
const int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceType_descriptor();
inline const ::std::string& DeviceType_Name(DeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceType_descriptor(), value);
}
inline bool DeviceType_Parse(
    const ::std::string& name, DeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceType>(
    DeviceType_descriptor(), name, value);
}
enum DeviceModel {
  M1 = 1
};
bool DeviceModel_IsValid(int value);
const DeviceModel DeviceModel_MIN = M1;
const DeviceModel DeviceModel_MAX = M1;
const int DeviceModel_ARRAYSIZE = DeviceModel_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceModel_descriptor();
inline const ::std::string& DeviceModel_Name(DeviceModel value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceModel_descriptor(), value);
}
inline bool DeviceModel_Parse(
    const ::std::string& name, DeviceModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceModel>(
    DeviceModel_descriptor(), name, value);
}
enum ConfigName {
  LAN = 1,
  WLAN = 2,
  WIFI = 3,
  TIME = 4,
  WSN = 5,
  CAN = 6
};
bool ConfigName_IsValid(int value);
const ConfigName ConfigName_MIN = LAN;
const ConfigName ConfigName_MAX = CAN;
const int ConfigName_ARRAYSIZE = ConfigName_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConfigName_descriptor();
inline const ::std::string& ConfigName_Name(ConfigName value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConfigName_descriptor(), value);
}
inline bool ConfigName_Parse(
    const ::std::string& name, ConfigName* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConfigName>(
    ConfigName_descriptor(), name, value);
}
enum Enable {
  DISABLE = 0,
  ABLE = 1
};
bool Enable_IsValid(int value);
const Enable Enable_MIN = DISABLE;
const Enable Enable_MAX = ABLE;
const int Enable_ARRAYSIZE = Enable_MAX + 1;

const ::google::protobuf::EnumDescriptor* Enable_descriptor();
inline const ::std::string& Enable_Name(Enable value) {
  return ::google::protobuf::internal::NameOfEnum(
    Enable_descriptor(), value);
}
inline bool Enable_Parse(
    const ::std::string& name, Enable* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Enable>(
    Enable_descriptor(), name, value);
}
enum NodeType {
  BLACK = 1,
  WHITE = 2,
  UNADDED = 3
};
bool NodeType_IsValid(int value);
const NodeType NodeType_MIN = BLACK;
const NodeType NodeType_MAX = UNADDED;
const int NodeType_ARRAYSIZE = NodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeType_descriptor();
inline const ::std::string& NodeType_Name(NodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeType_descriptor(), value);
}
inline bool NodeType_Parse(
    const ::std::string& name, NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeType>(
    NodeType_descriptor(), name, value);
}
enum DataType {
  ALL = 0,
  REAL = 1,
  ALARM = 2
};
bool DataType_IsValid(int value);
const DataType DataType_MIN = ALL;
const DataType DataType_MAX = ALARM;
const int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataType_descriptor();
inline const ::std::string& DataType_Name(DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataType_descriptor(), value);
}
inline bool DataType_Parse(
    const ::std::string& name, DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
enum LogType {
  ALL_TYPE = 1,
  SECURITY = 2,
  DEVICE = 3,
  SYSTEM = 4,
  BUSINESS = 5
};
bool LogType_IsValid(int value);
const LogType LogType_MIN = ALL_TYPE;
const LogType LogType_MAX = BUSINESS;
const int LogType_ARRAYSIZE = LogType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogType_descriptor();
inline const ::std::string& LogType_Name(LogType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogType_descriptor(), value);
}
inline bool LogType_Parse(
    const ::std::string& name, LogType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogType>(
    LogType_descriptor(), name, value);
}
enum ReceiveStatus {
  RECEIVE_OK = 1,
  RECEIVE_ERROR = 2
};
bool ReceiveStatus_IsValid(int value);
const ReceiveStatus ReceiveStatus_MIN = RECEIVE_OK;
const ReceiveStatus ReceiveStatus_MAX = RECEIVE_ERROR;
const int ReceiveStatus_ARRAYSIZE = ReceiveStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReceiveStatus_descriptor();
inline const ::std::string& ReceiveStatus_Name(ReceiveStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReceiveStatus_descriptor(), value);
}
inline bool ReceiveStatus_Parse(
    const ::std::string& name, ReceiveStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReceiveStatus>(
    ReceiveStatus_descriptor(), name, value);
}
enum ExecuteStatus {
  DOWNLOAD_OK = 1,
  DOWNLOAD_ERROR = 2,
  UPGRADE_ERROR = 3,
  UPGRADE_OK = 4
};
bool ExecuteStatus_IsValid(int value);
const ExecuteStatus ExecuteStatus_MIN = DOWNLOAD_OK;
const ExecuteStatus ExecuteStatus_MAX = UPGRADE_OK;
const int ExecuteStatus_ARRAYSIZE = ExecuteStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecuteStatus_descriptor();
inline const ::std::string& ExecuteStatus_Name(ExecuteStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecuteStatus_descriptor(), value);
}
inline bool ExecuteStatus_Parse(
    const ::std::string& name, ExecuteStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecuteStatus>(
    ExecuteStatus_descriptor(), name, value);
}
// ===================================================================

class NWPb : public ::google::protobuf::Message {
 public:
  NWPb();
  virtual ~NWPb();

  NWPb(const NWPb& from);

  inline NWPb& operator=(const NWPb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NWPb& default_instance();

  void Swap(NWPb* other);

  // implements Message ----------------------------------------------

  NWPb* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NWPb& from);
  void MergeFrom(const NWPb& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Request rqst = 1;
  inline bool has_rqst() const;
  inline void clear_rqst();
  static const int kRqstFieldNumber = 1;
  inline const ::Request& rqst() const;
  inline ::Request* mutable_rqst();
  inline ::Request* release_rqst();
  inline void set_allocated_rqst(::Request* rqst);

  // optional .Response rsps = 2;
  inline bool has_rsps() const;
  inline void clear_rsps();
  static const int kRspsFieldNumber = 2;
  inline const ::Response& rsps() const;
  inline ::Response* mutable_rsps();
  inline ::Response* release_rsps();
  inline void set_allocated_rsps(::Response* rsps);

  // optional .Notify ntf = 3;
  inline bool has_ntf() const;
  inline void clear_ntf();
  static const int kNtfFieldNumber = 3;
  inline const ::Notify& ntf() const;
  inline ::Notify* mutable_ntf();
  inline ::Notify* release_ntf();
  inline void set_allocated_ntf(::Notify* ntf);

  // @@protoc_insertion_point(class_scope:NWPb)
 private:
  inline void set_has_rqst();
  inline void clear_has_rqst();
  inline void set_has_rsps();
  inline void clear_has_rsps();
  inline void set_has_ntf();
  inline void clear_has_ntf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Request* rqst_;
  ::Response* rsps_;
  ::Notify* ntf_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static NWPb* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);

  // required uint32 sequence = 2;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // required .Command command = 3;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 3;
  inline ::Command command() const;
  inline void set_command(::Command value);

  // optional bytes content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:Request)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 sequence_;
  ::std::string* content_;
  int command_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_Error Error;
  static const Error NWPB_ERROR_OK = Response_Error_NWPB_ERROR_OK;
  static const Error NWPB_ERROR_DECRYPT_FAILED = Response_Error_NWPB_ERROR_DECRYPT_FAILED;
  static const Error NWPB_ERROR_USER_PASSWORD_INVALID = Response_Error_NWPB_ERROR_USER_PASSWORD_INVALID;
  static const Error NWPB_ERROR_USER_INVALID_STATUS = Response_Error_NWPB_ERROR_USER_INVALID_STATUS;
  static const Error NWPB_ERROR_USER_NOT_EXIST = Response_Error_NWPB_ERROR_USER_NOT_EXIST;
  static const Error NWPB_ERROR_USER_NOT_LOGIN = Response_Error_NWPB_ERROR_USER_NOT_LOGIN;
  static const Error NWPB_ERROR_UNSUPPORT_SUBSCRIBE_TYPE = Response_Error_NWPB_ERROR_UNSUPPORT_SUBSCRIBE_TYPE;
  static const Error NWPB_ERROR_INVALID_TIME_VALUE = Response_Error_NWPB_ERROR_INVALID_TIME_VALUE;
  static const Error NWPB_ERROR_UNSUPPORT_NODELIST_GET_TYPE = Response_Error_NWPB_ERROR_UNSUPPORT_NODELIST_GET_TYPE;
  static const Error NWPB_ERROR_UNSUPPORT_ENCRYPT_TYPE = Response_Error_NWPB_ERROR_UNSUPPORT_ENCRYPT_TYPE;
  static const Error NWPB_ERROR_NODE_UNSUPPORT_COMMAND = Response_Error_NWPB_ERROR_NODE_UNSUPPORT_COMMAND;
  static const Error NWPB_ERROR_INVALID_SENSOR_NO = Response_Error_NWPB_ERROR_INVALID_SENSOR_NO;
  static const Error NWPB_ERROR_INVALID_NODE_ID = Response_Error_NWPB_ERROR_INVALID_NODE_ID;
  static const Error NWPB_ERROR_NONE_THRESHOLD_DATA = Response_Error_NWPB_ERROR_NONE_THRESHOLD_DATA;
  static const Error NWPB_ERROR_USER_ALREADY_EXIST = Response_Error_NWPB_ERROR_USER_ALREADY_EXIST;
  static const Error NWPB_ERROR_WRONG_OLD_PASSWORD = Response_Error_NWPB_ERROR_WRONG_OLD_PASSWORD;
  static const Error NWPB_ERROR_USER_ALREADY_LOGOUT = Response_Error_NWPB_ERROR_USER_ALREADY_LOGOUT;
  static const Error NWPB_ERROR_INVALID_PROTOCOL_VERSION = Response_Error_NWPB_ERROR_INVALID_PROTOCOL_VERSION;
  static const Error NWPB_ERROR_INVALID_BW_CONFIG_TYPE = Response_Error_NWPB_ERROR_INVALID_BW_CONFIG_TYPE;
  static const Error NWPB_ERROR_INVALID_BW_CONFIG_COMMAND = Response_Error_NWPB_ERROR_INVALID_BW_CONFIG_COMMAND;
  static const Error NWPB_ERROR_USER_DELETE_FORBIDDEN = Response_Error_NWPB_ERROR_USER_DELETE_FORBIDDEN;
  static const Error NWPB_ERROR_UNSUPPORT_CONFIG_NAME = Response_Error_NWPB_ERROR_UNSUPPORT_CONFIG_NAME;
  static const Error NWPB_ERROR_UNSUPPORT_COMMON_CMD = Response_Error_NWPB_ERROR_UNSUPPORT_COMMON_CMD;
  static const Error NWPB_ERROR_USERNAME_NULL = Response_Error_NWPB_ERROR_USERNAME_NULL;
  static const Error NWPB_ERROR_SENSOR_NOT_EXIST = Response_Error_NWPB_ERROR_SENSOR_NOT_EXIST;
  static const Error NWPB_ERROR_INVALID_SEND_INTERVAL = Response_Error_NWPB_ERROR_INVALID_SEND_INTERVAL;
  static const Error NWPB_ERROR_ZERO_SEND_INTERVAL = Response_Error_NWPB_ERROR_ZERO_SEND_INTERVAL;
  static const Error NWPB_ERROR_INVALID_INPUT_PARAM = Response_Error_NWPB_ERROR_INVALID_INPUT_PARAM;
  static const Error NWPB_ERROR_SEND_INTERVAL_TOO_SHORT = Response_Error_NWPB_ERROR_SEND_INTERVAL_TOO_SHORT;
  static const Error NWPB_ERROR_SEND_INTERVAL_TOO_LONG = Response_Error_NWPB_ERROR_SEND_INTERVAL_TOO_LONG;
  static const Error NWPB_ERROR_INVALID_NW_ID = Response_Error_NWPB_ERROR_INVALID_NW_ID;
  static const Error NWPB_ERROR_SESSION_TIMEOUT = Response_Error_NWPB_ERROR_SESSION_TIMEOUT;
  static const Error NWPB_ERROR_SESSION_NOT_EXIST = Response_Error_NWPB_ERROR_SESSION_NOT_EXIST;
  static const Error NWPB_ERROR_NODE_NOT_REGISTER = Response_Error_NWPB_ERROR_NODE_NOT_REGISTER;
  static const Error NWPB_ERROR_CHOOSE_LONGER_PASSWORD = Response_Error_NWPB_ERROR_CHOOSE_LONGER_PASSWORD;
  static const Error NWPB_ERROR_TOO_MANY_USERS = Response_Error_NWPB_ERROR_TOO_MANY_USERS;
  static const Error NWPB_ERROR_KICKOUT = Response_Error_NWPB_ERROR_KICKOUT;
  static const Error NWPB_ERROR_USER_DELETED = Response_Error_NWPB_ERROR_USER_DELETED;
  static const Error NWPB_ERROR_MSG_SERVICE_ERROR = Response_Error_NWPB_ERROR_MSG_SERVICE_ERROR;
  static const Error NWPB_ERROR_WSN_SERVICE_UNAVAILABLE = Response_Error_NWPB_ERROR_WSN_SERVICE_UNAVAILABLE;
  static const Error NWPB_ERROR_WSN_SERVICE_ERROR = Response_Error_NWPB_ERROR_WSN_SERVICE_ERROR;
  static const Error NWPB_ERROR_DB_SERVICE_UNAVAILABLE = Response_Error_NWPB_ERROR_DB_SERVICE_UNAVAILABLE;
  static const Error NWPB_ERROR_DB_SERVICE_ERROR = Response_Error_NWPB_ERROR_DB_SERVICE_ERROR;
  static const Error NWPB_ERROR_USER_SERVICE_UNAVAILABLE = Response_Error_NWPB_ERROR_USER_SERVICE_UNAVAILABLE;
  static const Error NWPB_ERROR_USER_SERVICE_ERROR = Response_Error_NWPB_ERROR_USER_SERVICE_ERROR;
  static const Error NWPB_ERROR_UNSUPPORT_FUNCTION = Response_Error_NWPB_ERROR_UNSUPPORT_FUNCTION;
  static const Error NWPB_ERROR_WSN_NET_TIMEOUT = Response_Error_NWPB_ERROR_WSN_NET_TIMEOUT;
  static const Error NWPB_ERROR_WSN_NODE_SENSOR_NOT_READY = Response_Error_NWPB_ERROR_WSN_NODE_SENSOR_NOT_READY;
  static const Error NWPB_ERROR_SET_COMMAND_IN_PROCESSSING = Response_Error_NWPB_ERROR_SET_COMMAND_IN_PROCESSSING;
  static const Error NWPB_ERROR_ONLY_SUPPORT_SET_ONE_THRESHOLD = Response_Error_NWPB_ERROR_ONLY_SUPPORT_SET_ONE_THRESHOLD;
  static const Error NWPB_ERROR_WSN_NET_OPERATION_FAILED = Response_Error_NWPB_ERROR_WSN_NET_OPERATION_FAILED;
  static const Error NWPB_ERROR_LOG_XML_ERROR = Response_Error_NWPB_ERROR_LOG_XML_ERROR;
  static const Error NWPB_ERROR_XML_OPERATION_ERROR = Response_Error_NWPB_ERROR_XML_OPERATION_ERROR;
  static const Error NWPB_ERROR_SERVER_LOGIC_ERROR = Response_Error_NWPB_ERROR_SERVER_LOGIC_ERROR;
  static const Error NWPB_ERROR_NODE_OPERATION = Response_Error_NWPB_ERROR_NODE_OPERATION;
  static const Error NWPB_ERROR_WAIT_OTHER_MAIN_OPERATION = Response_Error_NWPB_ERROR_WAIT_OTHER_MAIN_OPERATION;
  static const Error NWPB_ERROR_MAIN_NODE_FAILED = Response_Error_NWPB_ERROR_MAIN_NODE_FAILED;
  static const Error NWPB_ERROR_MAIN_NODE_SET_FAILED = Response_Error_NWPB_ERROR_MAIN_NODE_SET_FAILED;
  static const Error NWPB_ERROR_AUTOREG_UNREGISTERING = Response_Error_NWPB_ERROR_AUTOREG_UNREGISTERING;
  static const Error NWPB_ERROR_IPC_SERVICE_ERROR = Response_Error_NWPB_ERROR_IPC_SERVICE_ERROR;
  static const Error NWPB_ERROR_WAIT_WIFI_CONNECTING = Response_Error_NWPB_ERROR_WAIT_WIFI_CONNECTING;
  static const Error NWPB_ERROR_GENERAL_OPERATION_TIMEOUT = Response_Error_NWPB_ERROR_GENERAL_OPERATION_TIMEOUT;
  static const Error NWPB_ERROR_VWLITE_CONNECT_FAILED = Response_Error_NWPB_ERROR_VWLITE_CONNECT_FAILED;
  static const Error NWPB_ERROR_VWLITE_DISCONNECT = Response_Error_NWPB_ERROR_VWLITE_DISCONNECT;
  static const Error NWPB_ERROR_VWLITE_RESPONSE_BAD = Response_Error_NWPB_ERROR_VWLITE_RESPONSE_BAD;
  static const Error NWPB_ERROR_DEVICE_BINDING_FAIL = Response_Error_NWPB_ERROR_DEVICE_BINDING_FAIL;
  static const Error NWPB_ERROR_DEVICE_BINDING_NO_VC_ACK = Response_Error_NWPB_ERROR_DEVICE_BINDING_NO_VC_ACK;
  static const Error NWPB_ERROR_DEVICE_BINDING_NO_GW_ACK = Response_Error_NWPB_ERROR_DEVICE_BINDING_NO_GW_ACK;
  static const Error NWPB_ERROR_DEVICE_RM_BINDING_FAIL = Response_Error_NWPB_ERROR_DEVICE_RM_BINDING_FAIL;
  static const Error NWPB_ERROR_DEVICE_UNKNOW_ERROR = Response_Error_NWPB_ERROR_DEVICE_UNKNOW_ERROR;
  static inline bool Error_IsValid(int value) {
    return Response_Error_IsValid(value);
  }
  static const Error Error_MIN =
    Response_Error_Error_MIN;
  static const Error Error_MAX =
    Response_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    Response_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return Response_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return Response_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return Response_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);

  // required uint32 sequence = 2;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // required .Command command = 3;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 3;
  inline ::Command command() const;
  inline void set_command(::Command value);

  // required .Response.Error err = 4;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 4;
  inline ::Response_Error err() const;
  inline void set_err(::Response_Error value);

  // optional bytes content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:Response)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_err();
  inline void clear_has_err();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 sequence_;
  int command_;
  int err_;
  ::std::string* content_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Notify : public ::google::protobuf::Message {
 public:
  Notify();
  virtual ~Notify();

  Notify(const Notify& from);

  inline Notify& operator=(const Notify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Notify& default_instance();

  void Swap(Notify* other);

  // implements Message ----------------------------------------------

  Notify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Notify& from);
  void MergeFrom(const Notify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);

  // required .Command command = 2;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline ::Command command() const;
  inline void set_command(::Command value);

  // optional bytes content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:Notify)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_;
  int command_;
  ::std::string* content_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static Notify* default_instance_;
};
// -------------------------------------------------------------------

class LoginRqst : public ::google::protobuf::Message {
 public:
  LoginRqst();
  virtual ~LoginRqst();

  LoginRqst(const LoginRqst& from);

  inline LoginRqst& operator=(const LoginRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRqst& default_instance();

  void Swap(LoginRqst* other);

  // implements Message ----------------------------------------------

  LoginRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRqst& from);
  void MergeFrom(const LoginRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required uint32 expires = 2;
  inline bool has_expires() const;
  inline void clear_expires();
  static const int kExpiresFieldNumber = 2;
  inline ::google::protobuf::uint32 expires() const;
  inline void set_expires(::google::protobuf::uint32 value);

  // required .Encrypt encrypt = 3;
  inline bool has_encrypt() const;
  inline void clear_encrypt();
  static const int kEncryptFieldNumber = 3;
  inline ::Encrypt encrypt() const;
  inline void set_encrypt(::Encrypt value);

  // required bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:LoginRqst)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_expires();
  inline void clear_has_expires();
  inline void set_has_encrypt();
  inline void clear_has_encrypt();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_name_;
  ::google::protobuf::uint32 expires_;
  int encrypt_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static LoginRqst* default_instance_;
};
// -------------------------------------------------------------------

class LoginRsps : public ::google::protobuf::Message {
 public:
  LoginRsps();
  virtual ~LoginRsps();

  LoginRsps(const LoginRsps& from);

  inline LoginRsps& operator=(const LoginRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRsps& default_instance();

  void Swap(LoginRsps* other);

  // implements Message ----------------------------------------------

  LoginRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRsps& from);
  void MergeFrom(const LoginRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);

  // required uint32 expires = 2;
  inline bool has_expires() const;
  inline void clear_expires();
  static const int kExpiresFieldNumber = 2;
  inline ::google::protobuf::uint32 expires() const;
  inline void set_expires(::google::protobuf::uint32 value);

  // required uint32 nodes = 3;
  inline bool has_nodes() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 3;
  inline ::google::protobuf::uint32 nodes() const;
  inline void set_nodes(::google::protobuf::uint32 value);

  // required uint32 sessions = 4;
  inline bool has_sessions() const;
  inline void clear_sessions();
  static const int kSessionsFieldNumber = 4;
  inline ::google::protobuf::uint32 sessions() const;
  inline void set_sessions(::google::protobuf::uint32 value);

  // required bytes nw_id = 5;
  inline bool has_nw_id() const;
  inline void clear_nw_id();
  static const int kNwIdFieldNumber = 5;
  inline const ::std::string& nw_id() const;
  inline void set_nw_id(const ::std::string& value);
  inline void set_nw_id(const char* value);
  inline void set_nw_id(const void* value, size_t size);
  inline ::std::string* mutable_nw_id();
  inline ::std::string* release_nw_id();
  inline void set_allocated_nw_id(::std::string* nw_id);

  // required .Encrypt encrypt = 6;
  inline bool has_encrypt() const;
  inline void clear_encrypt();
  static const int kEncryptFieldNumber = 6;
  inline ::Encrypt encrypt() const;
  inline void set_encrypt(::Encrypt value);

  // @@protoc_insertion_point(class_scope:LoginRsps)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_expires();
  inline void clear_has_expires();
  inline void set_has_nodes();
  inline void clear_has_nodes();
  inline void set_has_sessions();
  inline void clear_has_sessions();
  inline void set_has_nw_id();
  inline void clear_has_nw_id();
  inline void set_has_encrypt();
  inline void clear_has_encrypt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 expires_;
  ::google::protobuf::uint32 nodes_;
  ::google::protobuf::uint32 sessions_;
  ::std::string* nw_id_;
  int encrypt_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static LoginRsps* default_instance_;
};
// -------------------------------------------------------------------

class ChangePasswordRqst : public ::google::protobuf::Message {
 public:
  ChangePasswordRqst();
  virtual ~ChangePasswordRqst();

  ChangePasswordRqst(const ChangePasswordRqst& from);

  inline ChangePasswordRqst& operator=(const ChangePasswordRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangePasswordRqst& default_instance();

  void Swap(ChangePasswordRqst* other);

  // implements Message ----------------------------------------------

  ChangePasswordRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangePasswordRqst& from);
  void MergeFrom(const ChangePasswordRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string old_password = 1;
  inline bool has_old_password() const;
  inline void clear_old_password();
  static const int kOldPasswordFieldNumber = 1;
  inline const ::std::string& old_password() const;
  inline void set_old_password(const ::std::string& value);
  inline void set_old_password(const char* value);
  inline void set_old_password(const char* value, size_t size);
  inline ::std::string* mutable_old_password();
  inline ::std::string* release_old_password();
  inline void set_allocated_old_password(::std::string* old_password);

  // required string new_password = 2;
  inline bool has_new_password() const;
  inline void clear_new_password();
  static const int kNewPasswordFieldNumber = 2;
  inline const ::std::string& new_password() const;
  inline void set_new_password(const ::std::string& value);
  inline void set_new_password(const char* value);
  inline void set_new_password(const char* value, size_t size);
  inline ::std::string* mutable_new_password();
  inline ::std::string* release_new_password();
  inline void set_allocated_new_password(::std::string* new_password);

  // @@protoc_insertion_point(class_scope:ChangePasswordRqst)
 private:
  inline void set_has_old_password();
  inline void clear_has_old_password();
  inline void set_has_new_password();
  inline void clear_has_new_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* old_password_;
  ::std::string* new_password_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static ChangePasswordRqst* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatRqst : public ::google::protobuf::Message {
 public:
  HeartbeatRqst();
  virtual ~HeartbeatRqst();

  HeartbeatRqst(const HeartbeatRqst& from);

  inline HeartbeatRqst& operator=(const HeartbeatRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatRqst& default_instance();

  void Swap(HeartbeatRqst* other);

  // implements Message ----------------------------------------------

  HeartbeatRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatRqst& from);
  void MergeFrom(const HeartbeatRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 expires = 1;
  inline bool has_expires() const;
  inline void clear_expires();
  static const int kExpiresFieldNumber = 1;
  inline ::google::protobuf::uint32 expires() const;
  inline void set_expires(::google::protobuf::uint32 value);

  // required uint64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:HeartbeatRqst)
 private:
  inline void set_has_expires();
  inline void clear_has_expires();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 expires_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatRqst* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatRsps : public ::google::protobuf::Message {
 public:
  HeartbeatRsps();
  virtual ~HeartbeatRsps();

  HeartbeatRsps(const HeartbeatRsps& from);

  inline HeartbeatRsps& operator=(const HeartbeatRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatRsps& default_instance();

  void Swap(HeartbeatRsps* other);

  // implements Message ----------------------------------------------

  HeartbeatRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatRsps& from);
  void MergeFrom(const HeartbeatRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 expires = 1;
  inline bool has_expires() const;
  inline void clear_expires();
  static const int kExpiresFieldNumber = 1;
  inline ::google::protobuf::uint32 expires() const;
  inline void set_expires(::google::protobuf::uint32 value);

  // required uint32 capability = 2;
  inline bool has_capability() const;
  inline void clear_capability();
  static const int kCapabilityFieldNumber = 2;
  inline ::google::protobuf::uint32 capability() const;
  inline void set_capability(::google::protobuf::uint32 value);

  // required uint32 nodes = 3;
  inline bool has_nodes() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 3;
  inline ::google::protobuf::uint32 nodes() const;
  inline void set_nodes(::google::protobuf::uint32 value);

  // required uint32 sessions = 4;
  inline bool has_sessions() const;
  inline void clear_sessions();
  static const int kSessionsFieldNumber = 4;
  inline ::google::protobuf::uint32 sessions() const;
  inline void set_sessions(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:HeartbeatRsps)
 private:
  inline void set_has_expires();
  inline void clear_has_expires();
  inline void set_has_capability();
  inline void clear_has_capability();
  inline void set_has_nodes();
  inline void clear_has_nodes();
  inline void set_has_sessions();
  inline void clear_has_sessions();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 expires_;
  ::google::protobuf::uint32 capability_;
  ::google::protobuf::uint32 nodes_;
  ::google::protobuf::uint32 sessions_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatRsps* default_instance_;
};
// -------------------------------------------------------------------

class RegisterRqst : public ::google::protobuf::Message {
 public:
  RegisterRqst();
  virtual ~RegisterRqst();

  RegisterRqst(const RegisterRqst& from);

  inline RegisterRqst& operator=(const RegisterRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRqst& default_instance();

  void Swap(RegisterRqst* other);

  // implements Message ----------------------------------------------

  RegisterRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterRqst& from);
  void MergeFrom(const RegisterRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DeviceType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::DeviceType type() const;
  inline void set_type(::DeviceType value);

  // required string nw_id = 2;
  inline bool has_nw_id() const;
  inline void clear_nw_id();
  static const int kNwIdFieldNumber = 2;
  inline const ::std::string& nw_id() const;
  inline void set_nw_id(const ::std::string& value);
  inline void set_nw_id(const char* value);
  inline void set_nw_id(const char* value, size_t size);
  inline ::std::string* mutable_nw_id();
  inline ::std::string* release_nw_id();
  inline void set_allocated_nw_id(::std::string* nw_id);

  // required string manufactory = 3;
  inline bool has_manufactory() const;
  inline void clear_manufactory();
  static const int kManufactoryFieldNumber = 3;
  inline const ::std::string& manufactory() const;
  inline void set_manufactory(const ::std::string& value);
  inline void set_manufactory(const char* value);
  inline void set_manufactory(const char* value, size_t size);
  inline ::std::string* mutable_manufactory();
  inline ::std::string* release_manufactory();
  inline void set_allocated_manufactory(::std::string* manufactory);

  // required .DeviceModel model = 4;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 4;
  inline ::DeviceModel model() const;
  inline void set_model(::DeviceModel value);

  // required uint32 nodes = 5;
  inline bool has_nodes() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 5;
  inline ::google::protobuf::uint32 nodes() const;
  inline void set_nodes(::google::protobuf::uint32 value);

  // required uint32 session = 6;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 6;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RegisterRqst)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_nw_id();
  inline void clear_has_nw_id();
  inline void set_has_manufactory();
  inline void clear_has_manufactory();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_nodes();
  inline void clear_has_nodes();
  inline void set_has_session();
  inline void clear_has_session();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nw_id_;
  int type_;
  int model_;
  ::std::string* manufactory_;
  ::google::protobuf::uint32 nodes_;
  ::google::protobuf::uint32 session_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static RegisterRqst* default_instance_;
};
// -------------------------------------------------------------------

class RegisterRsps : public ::google::protobuf::Message {
 public:
  RegisterRsps();
  virtual ~RegisterRsps();

  RegisterRsps(const RegisterRsps& from);

  inline RegisterRsps& operator=(const RegisterRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRsps& default_instance();

  void Swap(RegisterRsps* other);

  // implements Message ----------------------------------------------

  RegisterRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterRsps& from);
  void MergeFrom(const RegisterRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // required uint32 expires = 2;
  inline bool has_expires() const;
  inline void clear_expires();
  static const int kExpiresFieldNumber = 2;
  inline ::google::protobuf::uint32 expires() const;
  inline void set_expires(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RegisterRsps)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_expires();
  inline void clear_has_expires();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 expires_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static RegisterRsps* default_instance_;
};
// -------------------------------------------------------------------

class GetNWInfoRqst : public ::google::protobuf::Message {
 public:
  GetNWInfoRqst();
  virtual ~GetNWInfoRqst();

  GetNWInfoRqst(const GetNWInfoRqst& from);

  inline GetNWInfoRqst& operator=(const GetNWInfoRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNWInfoRqst& default_instance();

  void Swap(GetNWInfoRqst* other);

  // implements Message ----------------------------------------------

  GetNWInfoRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNWInfoRqst& from);
  void MergeFrom(const GetNWInfoRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes nw_id = 1;
  inline bool has_nw_id() const;
  inline void clear_nw_id();
  static const int kNwIdFieldNumber = 1;
  inline const ::std::string& nw_id() const;
  inline void set_nw_id(const ::std::string& value);
  inline void set_nw_id(const char* value);
  inline void set_nw_id(const void* value, size_t size);
  inline ::std::string* mutable_nw_id();
  inline ::std::string* release_nw_id();
  inline void set_allocated_nw_id(::std::string* nw_id);

  // @@protoc_insertion_point(class_scope:GetNWInfoRqst)
 private:
  inline void set_has_nw_id();
  inline void clear_has_nw_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nw_id_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetNWInfoRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetNWInfoRsps : public ::google::protobuf::Message {
 public:
  GetNWInfoRsps();
  virtual ~GetNWInfoRsps();

  GetNWInfoRsps(const GetNWInfoRsps& from);

  inline GetNWInfoRsps& operator=(const GetNWInfoRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNWInfoRsps& default_instance();

  void Swap(GetNWInfoRsps* other);

  // implements Message ----------------------------------------------

  GetNWInfoRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNWInfoRsps& from);
  void MergeFrom(const GetNWInfoRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string manufactory = 1;
  inline bool has_manufactory() const;
  inline void clear_manufactory();
  static const int kManufactoryFieldNumber = 1;
  inline const ::std::string& manufactory() const;
  inline void set_manufactory(const ::std::string& value);
  inline void set_manufactory(const char* value);
  inline void set_manufactory(const char* value, size_t size);
  inline ::std::string* mutable_manufactory();
  inline ::std::string* release_manufactory();
  inline void set_allocated_manufactory(::std::string* manufactory);

  // required .DeviceModel model = 2;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 2;
  inline ::DeviceModel model() const;
  inline void set_model(::DeviceModel value);

  // required uint32 node_count = 3;
  inline bool has_node_count() const;
  inline void clear_node_count();
  static const int kNodeCountFieldNumber = 3;
  inline ::google::protobuf::uint32 node_count() const;
  inline void set_node_count(::google::protobuf::uint32 value);

  // required string _3G = 4;
  inline bool has__3g() const;
  inline void clear__3g();
  static const int k3GFieldNumber = 4;
  inline const ::std::string& _3g() const;
  inline void set__3g(const ::std::string& value);
  inline void set__3g(const char* value);
  inline void set__3g(const char* value, size_t size);
  inline ::std::string* mutable__3g();
  inline ::std::string* release__3g();
  inline void set_allocated__3g(::std::string* _3g);

  // required string storage = 5;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 5;
  inline const ::std::string& storage() const;
  inline void set_storage(const ::std::string& value);
  inline void set_storage(const char* value);
  inline void set_storage(const char* value, size_t size);
  inline ::std::string* mutable_storage();
  inline ::std::string* release_storage();
  inline void set_allocated_storage(::std::string* storage);

  // required uint32 space = 6;
  inline bool has_space() const;
  inline void clear_space();
  static const int kSpaceFieldNumber = 6;
  inline ::google::protobuf::uint32 space() const;
  inline void set_space(::google::protobuf::uint32 value);

  // required bytes nw_id = 7;
  inline bool has_nw_id() const;
  inline void clear_nw_id();
  static const int kNwIdFieldNumber = 7;
  inline const ::std::string& nw_id() const;
  inline void set_nw_id(const ::std::string& value);
  inline void set_nw_id(const char* value);
  inline void set_nw_id(const void* value, size_t size);
  inline ::std::string* mutable_nw_id();
  inline ::std::string* release_nw_id();
  inline void set_allocated_nw_id(::std::string* nw_id);

  // required string band = 8;
  inline bool has_band() const;
  inline void clear_band();
  static const int kBandFieldNumber = 8;
  inline const ::std::string& band() const;
  inline void set_band(const ::std::string& value);
  inline void set_band(const char* value);
  inline void set_band(const char* value, size_t size);
  inline ::std::string* mutable_band();
  inline ::std::string* release_band();
  inline void set_allocated_band(::std::string* band);

  // required string firmware = 9;
  inline bool has_firmware() const;
  inline void clear_firmware();
  static const int kFirmwareFieldNumber = 9;
  inline const ::std::string& firmware() const;
  inline void set_firmware(const ::std::string& value);
  inline void set_firmware(const char* value);
  inline void set_firmware(const char* value, size_t size);
  inline ::std::string* mutable_firmware();
  inline ::std::string* release_firmware();
  inline void set_allocated_firmware(::std::string* firmware);

  // required string position = 10;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 10;
  inline const ::std::string& position() const;
  inline void set_position(const ::std::string& value);
  inline void set_position(const char* value);
  inline void set_position(const char* value, size_t size);
  inline ::std::string* mutable_position();
  inline ::std::string* release_position();
  inline void set_allocated_position(::std::string* position);

  // required string gps = 11;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGpsFieldNumber = 11;
  inline const ::std::string& gps() const;
  inline void set_gps(const ::std::string& value);
  inline void set_gps(const char* value);
  inline void set_gps(const char* value, size_t size);
  inline ::std::string* mutable_gps();
  inline ::std::string* release_gps();
  inline void set_allocated_gps(::std::string* gps);

  // @@protoc_insertion_point(class_scope:GetNWInfoRsps)
 private:
  inline void set_has_manufactory();
  inline void clear_has_manufactory();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_node_count();
  inline void clear_has_node_count();
  inline void set_has__3g();
  inline void clear_has__3g();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_space();
  inline void clear_has_space();
  inline void set_has_nw_id();
  inline void clear_has_nw_id();
  inline void set_has_band();
  inline void clear_has_band();
  inline void set_has_firmware();
  inline void clear_has_firmware();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_gps();
  inline void clear_has_gps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* manufactory_;
  int model_;
  ::google::protobuf::uint32 node_count_;
  ::std::string* _3g_;
  ::std::string* storage_;
  ::std::string* nw_id_;
  ::std::string* band_;
  ::std::string* firmware_;
  ::std::string* position_;
  ::std::string* gps_;
  ::google::protobuf::uint32 space_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetNWInfoRsps* default_instance_;
};
// -------------------------------------------------------------------

class SetAutoParamRqst : public ::google::protobuf::Message {
 public:
  SetAutoParamRqst();
  virtual ~SetAutoParamRqst();

  SetAutoParamRqst(const SetAutoParamRqst& from);

  inline SetAutoParamRqst& operator=(const SetAutoParamRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetAutoParamRqst& default_instance();

  void Swap(SetAutoParamRqst* other);

  // implements Message ----------------------------------------------

  SetAutoParamRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetAutoParamRqst& from);
  void MergeFrom(const SetAutoParamRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline ::google::protobuf::uint32 enable() const;
  inline void set_enable(::google::protobuf::uint32 value);

  // required uint32 ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);

  // required uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required string username = 4;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 4;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required uint32 interval = 6;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 6;
  inline ::google::protobuf::uint32 interval() const;
  inline void set_interval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SetAutoParamRqst)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_interval();
  inline void clear_has_interval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 enable_;
  ::google::protobuf::uint32 ip_;
  ::std::string* username_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 interval_;
  ::std::string* password_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static SetAutoParamRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetAutoParamRsps : public ::google::protobuf::Message {
 public:
  GetAutoParamRsps();
  virtual ~GetAutoParamRsps();

  GetAutoParamRsps(const GetAutoParamRsps& from);

  inline GetAutoParamRsps& operator=(const GetAutoParamRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAutoParamRsps& default_instance();

  void Swap(GetAutoParamRsps* other);

  // implements Message ----------------------------------------------

  GetAutoParamRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAutoParamRsps& from);
  void MergeFrom(const GetAutoParamRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline ::google::protobuf::uint32 enable() const;
  inline void set_enable(::google::protobuf::uint32 value);

  // required string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required string username = 4;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 4;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required uint32 interval = 6;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 6;
  inline ::google::protobuf::uint32 interval() const;
  inline void set_interval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GetAutoParamRsps)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_interval();
  inline void clear_has_interval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::google::protobuf::uint32 enable_;
  ::google::protobuf::uint32 port_;
  ::std::string* username_;
  ::std::string* password_;
  ::google::protobuf::uint32 interval_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetAutoParamRsps* default_instance_;
};
// -------------------------------------------------------------------

class SetConfigRqst : public ::google::protobuf::Message {
 public:
  SetConfigRqst();
  virtual ~SetConfigRqst();

  SetConfigRqst(const SetConfigRqst& from);

  inline SetConfigRqst& operator=(const SetConfigRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetConfigRqst& default_instance();

  void Swap(SetConfigRqst* other);

  // implements Message ----------------------------------------------

  SetConfigRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetConfigRqst& from);
  void MergeFrom(const SetConfigRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ConfigName name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline ::ConfigName name() const;
  inline void set_name(::ConfigName value);

  // required string config_file = 2;
  inline bool has_config_file() const;
  inline void clear_config_file();
  static const int kConfigFileFieldNumber = 2;
  inline const ::std::string& config_file() const;
  inline void set_config_file(const ::std::string& value);
  inline void set_config_file(const char* value);
  inline void set_config_file(const char* value, size_t size);
  inline ::std::string* mutable_config_file();
  inline ::std::string* release_config_file();
  inline void set_allocated_config_file(::std::string* config_file);

  // @@protoc_insertion_point(class_scope:SetConfigRqst)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_config_file();
  inline void clear_has_config_file();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* config_file_;
  int name_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static SetConfigRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetConfigRqst : public ::google::protobuf::Message {
 public:
  GetConfigRqst();
  virtual ~GetConfigRqst();

  GetConfigRqst(const GetConfigRqst& from);

  inline GetConfigRqst& operator=(const GetConfigRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetConfigRqst& default_instance();

  void Swap(GetConfigRqst* other);

  // implements Message ----------------------------------------------

  GetConfigRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetConfigRqst& from);
  void MergeFrom(const GetConfigRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ConfigName name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline ::ConfigName name() const;
  inline void set_name(::ConfigName value);

  // @@protoc_insertion_point(class_scope:GetConfigRqst)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int name_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetConfigRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetConfigRsps : public ::google::protobuf::Message {
 public:
  GetConfigRsps();
  virtual ~GetConfigRsps();

  GetConfigRsps(const GetConfigRsps& from);

  inline GetConfigRsps& operator=(const GetConfigRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetConfigRsps& default_instance();

  void Swap(GetConfigRsps* other);

  // implements Message ----------------------------------------------

  GetConfigRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetConfigRsps& from);
  void MergeFrom(const GetConfigRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string config_file = 1;
  inline bool has_config_file() const;
  inline void clear_config_file();
  static const int kConfigFileFieldNumber = 1;
  inline const ::std::string& config_file() const;
  inline void set_config_file(const ::std::string& value);
  inline void set_config_file(const char* value);
  inline void set_config_file(const char* value, size_t size);
  inline ::std::string* mutable_config_file();
  inline ::std::string* release_config_file();
  inline void set_allocated_config_file(::std::string* config_file);

  // @@protoc_insertion_point(class_scope:GetConfigRsps)
 private:
  inline void set_has_config_file();
  inline void clear_has_config_file();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* config_file_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetConfigRsps* default_instance_;
};
// -------------------------------------------------------------------

class QueryLogRqst : public ::google::protobuf::Message {
 public:
  QueryLogRqst();
  virtual ~QueryLogRqst();

  QueryLogRqst(const QueryLogRqst& from);

  inline QueryLogRqst& operator=(const QueryLogRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryLogRqst& default_instance();

  void Swap(QueryLogRqst* other);

  // implements Message ----------------------------------------------

  QueryLogRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryLogRqst& from);
  void MergeFrom(const QueryLogRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .LogType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::LogType type() const;
  inline void set_type(::LogType value);

  // required uint64 start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 start_time() const;
  inline void set_start_time(::google::protobuf::uint64 value);

  // required uint64 end_time = 3;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 end_time() const;
  inline void set_end_time(::google::protobuf::uint64 value);

  // required uint32 start_line = 4;
  inline bool has_start_line() const;
  inline void clear_start_line();
  static const int kStartLineFieldNumber = 4;
  inline ::google::protobuf::uint32 start_line() const;
  inline void set_start_line(::google::protobuf::uint32 value);

  // required uint32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:QueryLogRqst)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_start_line();
  inline void clear_has_start_line();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 start_time_;
  int type_;
  ::google::protobuf::uint32 start_line_;
  ::google::protobuf::uint64 end_time_;
  ::google::protobuf::uint32 count_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static QueryLogRqst* default_instance_;
};
// -------------------------------------------------------------------

class NWLog : public ::google::protobuf::Message {
 public:
  NWLog();
  virtual ~NWLog();

  NWLog(const NWLog& from);

  inline NWLog& operator=(const NWLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NWLog& default_instance();

  void Swap(NWLog* other);

  // implements Message ----------------------------------------------

  NWLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NWLog& from);
  void MergeFrom(const NWLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // required .LogType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::LogType type() const;
  inline void set_type(::LogType value);

  // required string message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:NWLog)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_;
  ::std::string* message_;
  int type_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static NWLog* default_instance_;
};
// -------------------------------------------------------------------

class QueryLogRsps : public ::google::protobuf::Message {
 public:
  QueryLogRsps();
  virtual ~QueryLogRsps();

  QueryLogRsps(const QueryLogRsps& from);

  inline QueryLogRsps& operator=(const QueryLogRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryLogRsps& default_instance();

  void Swap(QueryLogRsps* other);

  // implements Message ----------------------------------------------

  QueryLogRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryLogRsps& from);
  void MergeFrom(const QueryLogRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 total_count = 1;
  inline bool has_total_count() const;
  inline void clear_total_count();
  static const int kTotalCountFieldNumber = 1;
  inline ::google::protobuf::uint32 total_count() const;
  inline void set_total_count(::google::protobuf::uint32 value);

  // repeated .NWLog log = 2;
  inline int log_size() const;
  inline void clear_log();
  static const int kLogFieldNumber = 2;
  inline const ::NWLog& log(int index) const;
  inline ::NWLog* mutable_log(int index);
  inline ::NWLog* add_log();
  inline const ::google::protobuf::RepeatedPtrField< ::NWLog >&
      log() const;
  inline ::google::protobuf::RepeatedPtrField< ::NWLog >*
      mutable_log();

  // @@protoc_insertion_point(class_scope:QueryLogRsps)
 private:
  inline void set_has_total_count();
  inline void clear_has_total_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NWLog > log_;
  ::google::protobuf::uint32 total_count_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static QueryLogRsps* default_instance_;
};
// -------------------------------------------------------------------

class TimeSynchRqst : public ::google::protobuf::Message {
 public:
  TimeSynchRqst();
  virtual ~TimeSynchRqst();

  TimeSynchRqst(const TimeSynchRqst& from);

  inline TimeSynchRqst& operator=(const TimeSynchRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeSynchRqst& default_instance();

  void Swap(TimeSynchRqst* other);

  // implements Message ----------------------------------------------

  TimeSynchRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeSynchRqst& from);
  void MergeFrom(const TimeSynchRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // required string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required uint32 revision = 4;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 4;
  inline ::google::protobuf::uint32 revision() const;
  inline void set_revision(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TimeSynchRqst)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_revision();
  inline void clear_has_revision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_;
  ::std::string* ip_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 revision_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static TimeSynchRqst* default_instance_;
};
// -------------------------------------------------------------------

class RebootRqst : public ::google::protobuf::Message {
 public:
  RebootRqst();
  virtual ~RebootRqst();

  RebootRqst(const RebootRqst& from);

  inline RebootRqst& operator=(const RebootRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RebootRqst& default_instance();

  void Swap(RebootRqst* other);

  // implements Message ----------------------------------------------

  RebootRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RebootRqst& from);
  void MergeFrom(const RebootRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // required uint32 delay = 2;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 2;
  inline ::google::protobuf::uint32 delay() const;
  inline void set_delay(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RebootRqst)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_delay();
  inline void clear_has_delay();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* reason_;
  ::google::protobuf::uint32 delay_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static RebootRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeListRqst : public ::google::protobuf::Message {
 public:
  GetNodeListRqst();
  virtual ~GetNodeListRqst();

  GetNodeListRqst(const GetNodeListRqst& from);

  inline GetNodeListRqst& operator=(const GetNodeListRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeListRqst& default_instance();

  void Swap(GetNodeListRqst* other);

  // implements Message ----------------------------------------------

  GetNodeListRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeListRqst& from);
  void MergeFrom(const GetNodeListRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NodeType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::NodeType type() const;
  inline void set_type(::NodeType value);

  // required uint32 start_line = 2;
  inline bool has_start_line() const;
  inline void clear_start_line();
  static const int kStartLineFieldNumber = 2;
  inline ::google::protobuf::uint32 start_line() const;
  inline void set_start_line(::google::protobuf::uint32 value);

  // required uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GetNodeListRqst)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_start_line();
  inline void clear_has_start_line();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 start_line_;
  ::google::protobuf::uint32 count_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetNodeListRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeListRsps : public ::google::protobuf::Message {
 public:
  GetNodeListRsps();
  virtual ~GetNodeListRsps();

  GetNodeListRsps(const GetNodeListRsps& from);

  inline GetNodeListRsps& operator=(const GetNodeListRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeListRsps& default_instance();

  void Swap(GetNodeListRsps* other);

  // implements Message ----------------------------------------------

  GetNodeListRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeListRsps& from);
  void MergeFrom(const GetNodeListRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 total_count = 1;
  inline bool has_total_count() const;
  inline void clear_total_count();
  static const int kTotalCountFieldNumber = 1;
  inline ::google::protobuf::uint32 total_count() const;
  inline void set_total_count(::google::protobuf::uint32 value);

  // repeated .NodeEntry node_entry = 2;
  inline int node_entry_size() const;
  inline void clear_node_entry();
  static const int kNodeEntryFieldNumber = 2;
  inline const ::NodeEntry& node_entry(int index) const;
  inline ::NodeEntry* mutable_node_entry(int index);
  inline ::NodeEntry* add_node_entry();
  inline const ::google::protobuf::RepeatedPtrField< ::NodeEntry >&
      node_entry() const;
  inline ::google::protobuf::RepeatedPtrField< ::NodeEntry >*
      mutable_node_entry();

  // @@protoc_insertion_point(class_scope:GetNodeListRsps)
 private:
  inline void set_has_total_count();
  inline void clear_has_total_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NodeEntry > node_entry_;
  ::google::protobuf::uint32 total_count_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetNodeListRsps* default_instance_;
};
// -------------------------------------------------------------------

class NodeEntry : public ::google::protobuf::Message {
 public:
  NodeEntry();
  virtual ~NodeEntry();

  NodeEntry(const NodeEntry& from);

  inline NodeEntry& operator=(const NodeEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeEntry& default_instance();

  void Swap(NodeEntry* other);

  // implements Message ----------------------------------------------

  NodeEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeEntry& from);
  void MergeFrom(const NodeEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required uint32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // required uint32 sensor1 = 3;
  inline bool has_sensor1() const;
  inline void clear_sensor1();
  static const int kSensor1FieldNumber = 3;
  inline ::google::protobuf::uint32 sensor1() const;
  inline void set_sensor1(::google::protobuf::uint32 value);

  // required uint32 sensor2 = 4;
  inline bool has_sensor2() const;
  inline void clear_sensor2();
  static const int kSensor2FieldNumber = 4;
  inline ::google::protobuf::uint32 sensor2() const;
  inline void set_sensor2(::google::protobuf::uint32 value);

  // required uint32 sensor3 = 5;
  inline bool has_sensor3() const;
  inline void clear_sensor3();
  static const int kSensor3FieldNumber = 5;
  inline ::google::protobuf::uint32 sensor3() const;
  inline void set_sensor3(::google::protobuf::uint32 value);

  // required uint32 sensor4 = 6;
  inline bool has_sensor4() const;
  inline void clear_sensor4();
  static const int kSensor4FieldNumber = 6;
  inline ::google::protobuf::uint32 sensor4() const;
  inline void set_sensor4(::google::protobuf::uint32 value);

  // required uint32 sensor5 = 7;
  inline bool has_sensor5() const;
  inline void clear_sensor5();
  static const int kSensor5FieldNumber = 7;
  inline ::google::protobuf::uint32 sensor5() const;
  inline void set_sensor5(::google::protobuf::uint32 value);

  // required uint32 sensor6 = 8;
  inline bool has_sensor6() const;
  inline void clear_sensor6();
  static const int kSensor6FieldNumber = 8;
  inline ::google::protobuf::uint32 sensor6() const;
  inline void set_sensor6(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:NodeEntry)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_sensor1();
  inline void clear_has_sensor1();
  inline void set_has_sensor2();
  inline void clear_has_sensor2();
  inline void set_has_sensor3();
  inline void clear_has_sensor3();
  inline void set_has_sensor4();
  inline void clear_has_sensor4();
  inline void set_has_sensor5();
  inline void clear_has_sensor5();
  inline void set_has_sensor6();
  inline void clear_has_sensor6();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 sensor1_;
  ::google::protobuf::uint32 sensor2_;
  ::google::protobuf::uint32 sensor3_;
  ::google::protobuf::uint32 sensor4_;
  ::google::protobuf::uint32 sensor5_;
  ::google::protobuf::uint32 sensor6_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static NodeEntry* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeStatusRqst : public ::google::protobuf::Message {
 public:
  GetNodeStatusRqst();
  virtual ~GetNodeStatusRqst();

  GetNodeStatusRqst(const GetNodeStatusRqst& from);

  inline GetNodeStatusRqst& operator=(const GetNodeStatusRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeStatusRqst& default_instance();

  void Swap(GetNodeStatusRqst* other);

  // implements Message ----------------------------------------------

  GetNodeStatusRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeStatusRqst& from);
  void MergeFrom(const GetNodeStatusRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // @@protoc_insertion_point(class_scope:GetNodeStatusRqst)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetNodeStatusRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeStatusRsps : public ::google::protobuf::Message {
 public:
  GetNodeStatusRsps();
  virtual ~GetNodeStatusRsps();

  GetNodeStatusRsps(const GetNodeStatusRsps& from);

  inline GetNodeStatusRsps& operator=(const GetNodeStatusRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeStatusRsps& default_instance();

  void Swap(GetNodeStatusRsps* other);

  // implements Message ----------------------------------------------

  GetNodeStatusRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeStatusRsps& from);
  void MergeFrom(const GetNodeStatusRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NodeEntry node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::NodeEntry& node() const;
  inline ::NodeEntry* mutable_node();
  inline ::NodeEntry* release_node();
  inline void set_allocated_node(::NodeEntry* node);

  // @@protoc_insertion_point(class_scope:GetNodeStatusRsps)
 private:
  inline void set_has_node();
  inline void clear_has_node();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::NodeEntry* node_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetNodeStatusRsps* default_instance_;
};
// -------------------------------------------------------------------

class GetTopologyRsps : public ::google::protobuf::Message {
 public:
  GetTopologyRsps();
  virtual ~GetTopologyRsps();

  GetTopologyRsps(const GetTopologyRsps& from);

  inline GetTopologyRsps& operator=(const GetTopologyRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTopologyRsps& default_instance();

  void Swap(GetTopologyRsps* other);

  // implements Message ----------------------------------------------

  GetTopologyRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTopologyRsps& from);
  void MergeFrom(const GetTopologyRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Node node = 1;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::Node& node(int index) const;
  inline ::Node* mutable_node(int index);
  inline ::Node* add_node();
  inline const ::google::protobuf::RepeatedPtrField< ::Node >&
      node() const;
  inline ::google::protobuf::RepeatedPtrField< ::Node >*
      mutable_node();

  // @@protoc_insertion_point(class_scope:GetTopologyRsps)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Node > node_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetTopologyRsps* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes l_id = 1;
  inline bool has_l_id() const;
  inline void clear_l_id();
  static const int kLIdFieldNumber = 1;
  inline const ::std::string& l_id() const;
  inline void set_l_id(const ::std::string& value);
  inline void set_l_id(const char* value);
  inline void set_l_id(const void* value, size_t size);
  inline ::std::string* mutable_l_id();
  inline ::std::string* release_l_id();
  inline void set_allocated_l_id(::std::string* l_id);

  // required string s_id = 2;
  inline bool has_s_id() const;
  inline void clear_s_id();
  static const int kSIdFieldNumber = 2;
  inline const ::std::string& s_id() const;
  inline void set_s_id(const ::std::string& value);
  inline void set_s_id(const char* value);
  inline void set_s_id(const char* value, size_t size);
  inline ::std::string* mutable_s_id();
  inline ::std::string* release_s_id();
  inline void set_allocated_s_id(::std::string* s_id);

  // required uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // required .ParentNode parent = 5;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 5;
  inline const ::ParentNode& parent() const;
  inline ::ParentNode* mutable_parent();
  inline ::ParentNode* release_parent();
  inline void set_allocated_parent(::ParentNode* parent);

  // @@protoc_insertion_point(class_scope:Node)
 private:
  inline void set_has_l_id();
  inline void clear_has_l_id();
  inline void set_has_s_id();
  inline void clear_has_s_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_parent();
  inline void clear_has_parent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* l_id_;
  ::std::string* s_id_;
  ::google::protobuf::uint64 time_;
  ::ParentNode* parent_;
  ::google::protobuf::uint32 level_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class ParentNode : public ::google::protobuf::Message {
 public:
  ParentNode();
  virtual ~ParentNode();

  ParentNode(const ParentNode& from);

  inline ParentNode& operator=(const ParentNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParentNode& default_instance();

  void Swap(ParentNode* other);

  // implements Message ----------------------------------------------

  ParentNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParentNode& from);
  void MergeFrom(const ParentNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes l_id = 1;
  inline bool has_l_id() const;
  inline void clear_l_id();
  static const int kLIdFieldNumber = 1;
  inline const ::std::string& l_id() const;
  inline void set_l_id(const ::std::string& value);
  inline void set_l_id(const char* value);
  inline void set_l_id(const void* value, size_t size);
  inline ::std::string* mutable_l_id();
  inline ::std::string* release_l_id();
  inline void set_allocated_l_id(::std::string* l_id);

  // required string s_id = 2;
  inline bool has_s_id() const;
  inline void clear_s_id();
  static const int kSIdFieldNumber = 2;
  inline const ::std::string& s_id() const;
  inline void set_s_id(const ::std::string& value);
  inline void set_s_id(const char* value);
  inline void set_s_id(const char* value, size_t size);
  inline ::std::string* mutable_s_id();
  inline ::std::string* release_s_id();
  inline void set_allocated_s_id(::std::string* s_id);

  // required uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // required uint32 priority = 5;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 5;
  inline ::google::protobuf::uint32 priority() const;
  inline void set_priority(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ParentNode)
 private:
  inline void set_has_l_id();
  inline void clear_has_l_id();
  inline void set_has_s_id();
  inline void clear_has_s_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_priority();
  inline void clear_has_priority();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* l_id_;
  ::std::string* s_id_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 priority_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static ParentNode* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeNotificationNtf : public ::google::protobuf::Message {
 public:
  SubscribeNotificationNtf();
  virtual ~SubscribeNotificationNtf();

  SubscribeNotificationNtf(const SubscribeNotificationNtf& from);

  inline SubscribeNotificationNtf& operator=(const SubscribeNotificationNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeNotificationNtf& default_instance();

  void Swap(SubscribeNotificationNtf* other);

  // implements Message ----------------------------------------------

  SubscribeNotificationNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeNotificationNtf& from);
  void MergeFrom(const SubscribeNotificationNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SubscribeNotificationNtf_MessageType MessageType;
  static const MessageType NODE_STATE_CHANGE = SubscribeNotificationNtf_MessageType_NODE_STATE_CHANGE;
  static const MessageType MEMORY_CARD_FULL = SubscribeNotificationNtf_MessageType_MEMORY_CARD_FULL;
  static const MessageType MEMORY_CARD_ANOMALY = SubscribeNotificationNtf_MessageType_MEMORY_CARD_ANOMALY;
  static inline bool MessageType_IsValid(int value) {
    return SubscribeNotificationNtf_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    SubscribeNotificationNtf_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    SubscribeNotificationNtf_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    SubscribeNotificationNtf_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return SubscribeNotificationNtf_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return SubscribeNotificationNtf_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return SubscribeNotificationNtf_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SubscribeNotificationNtf.MessageType message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline ::SubscribeNotificationNtf_MessageType message() const;
  inline void set_message(::SubscribeNotificationNtf_MessageType value);

  // required uint32 param1 = 2;
  inline bool has_param1() const;
  inline void clear_param1();
  static const int kParam1FieldNumber = 2;
  inline ::google::protobuf::uint32 param1() const;
  inline void set_param1(::google::protobuf::uint32 value);

  // required uint32 param2 = 3;
  inline bool has_param2() const;
  inline void clear_param2();
  static const int kParam2FieldNumber = 3;
  inline ::google::protobuf::uint32 param2() const;
  inline void set_param2(::google::protobuf::uint32 value);

  // required string str_msg1 = 4;
  inline bool has_str_msg1() const;
  inline void clear_str_msg1();
  static const int kStrMsg1FieldNumber = 4;
  inline const ::std::string& str_msg1() const;
  inline void set_str_msg1(const ::std::string& value);
  inline void set_str_msg1(const char* value);
  inline void set_str_msg1(const char* value, size_t size);
  inline ::std::string* mutable_str_msg1();
  inline ::std::string* release_str_msg1();
  inline void set_allocated_str_msg1(::std::string* str_msg1);

  // required string str_msg2 = 5;
  inline bool has_str_msg2() const;
  inline void clear_str_msg2();
  static const int kStrMsg2FieldNumber = 5;
  inline const ::std::string& str_msg2() const;
  inline void set_str_msg2(const ::std::string& value);
  inline void set_str_msg2(const char* value);
  inline void set_str_msg2(const char* value, size_t size);
  inline ::std::string* mutable_str_msg2();
  inline ::std::string* release_str_msg2();
  inline void set_allocated_str_msg2(::std::string* str_msg2);

  // required uint64 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SubscribeNotificationNtf)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_param1();
  inline void clear_has_param1();
  inline void set_has_param2();
  inline void clear_has_param2();
  inline void set_has_str_msg1();
  inline void clear_has_str_msg1();
  inline void set_has_str_msg2();
  inline void clear_has_str_msg2();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int message_;
  ::google::protobuf::uint32 param1_;
  ::std::string* str_msg1_;
  ::std::string* str_msg2_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 param2_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static SubscribeNotificationNtf* default_instance_;
};
// -------------------------------------------------------------------

class DeviceBindingRqst : public ::google::protobuf::Message {
 public:
  DeviceBindingRqst();
  virtual ~DeviceBindingRqst();

  DeviceBindingRqst(const DeviceBindingRqst& from);

  inline DeviceBindingRqst& operator=(const DeviceBindingRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceBindingRqst& default_instance();

  void Swap(DeviceBindingRqst* other);

  // implements Message ----------------------------------------------

  DeviceBindingRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceBindingRqst& from);
  void MergeFrom(const DeviceBindingRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string valvectrl_id = 1;
  inline bool has_valvectrl_id() const;
  inline void clear_valvectrl_id();
  static const int kValvectrlIdFieldNumber = 1;
  inline const ::std::string& valvectrl_id() const;
  inline void set_valvectrl_id(const ::std::string& value);
  inline void set_valvectrl_id(const char* value);
  inline void set_valvectrl_id(const char* value, size_t size);
  inline ::std::string* mutable_valvectrl_id();
  inline ::std::string* release_valvectrl_id();
  inline void set_allocated_valvectrl_id(::std::string* valvectrl_id);

  // required string homegw_id = 2;
  inline bool has_homegw_id() const;
  inline void clear_homegw_id();
  static const int kHomegwIdFieldNumber = 2;
  inline const ::std::string& homegw_id() const;
  inline void set_homegw_id(const ::std::string& value);
  inline void set_homegw_id(const char* value);
  inline void set_homegw_id(const char* value, size_t size);
  inline ::std::string* mutable_homegw_id();
  inline ::std::string* release_homegw_id();
  inline void set_allocated_homegw_id(::std::string* homegw_id);

  // @@protoc_insertion_point(class_scope:DeviceBindingRqst)
 private:
  inline void set_has_valvectrl_id();
  inline void clear_has_valvectrl_id();
  inline void set_has_homegw_id();
  inline void clear_has_homegw_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* valvectrl_id_;
  ::std::string* homegw_id_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static DeviceBindingRqst* default_instance_;
};
// -------------------------------------------------------------------

class RmDeviceBindingRqst : public ::google::protobuf::Message {
 public:
  RmDeviceBindingRqst();
  virtual ~RmDeviceBindingRqst();

  RmDeviceBindingRqst(const RmDeviceBindingRqst& from);

  inline RmDeviceBindingRqst& operator=(const RmDeviceBindingRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RmDeviceBindingRqst& default_instance();

  void Swap(RmDeviceBindingRqst* other);

  // implements Message ----------------------------------------------

  RmDeviceBindingRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RmDeviceBindingRqst& from);
  void MergeFrom(const RmDeviceBindingRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string valvectrl_id = 1;
  inline bool has_valvectrl_id() const;
  inline void clear_valvectrl_id();
  static const int kValvectrlIdFieldNumber = 1;
  inline const ::std::string& valvectrl_id() const;
  inline void set_valvectrl_id(const ::std::string& value);
  inline void set_valvectrl_id(const char* value);
  inline void set_valvectrl_id(const char* value, size_t size);
  inline ::std::string* mutable_valvectrl_id();
  inline ::std::string* release_valvectrl_id();
  inline void set_allocated_valvectrl_id(::std::string* valvectrl_id);

  // required string homegw_id = 2;
  inline bool has_homegw_id() const;
  inline void clear_homegw_id();
  static const int kHomegwIdFieldNumber = 2;
  inline const ::std::string& homegw_id() const;
  inline void set_homegw_id(const ::std::string& value);
  inline void set_homegw_id(const char* value);
  inline void set_homegw_id(const char* value, size_t size);
  inline ::std::string* mutable_homegw_id();
  inline ::std::string* release_homegw_id();
  inline void set_allocated_homegw_id(::std::string* homegw_id);

  // @@protoc_insertion_point(class_scope:RmDeviceBindingRqst)
 private:
  inline void set_has_valvectrl_id();
  inline void clear_has_valvectrl_id();
  inline void set_has_homegw_id();
  inline void clear_has_homegw_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* valvectrl_id_;
  ::std::string* homegw_id_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static RmDeviceBindingRqst* default_instance_;
};
// -------------------------------------------------------------------

class RequestNodeDataUploadNtf : public ::google::protobuf::Message {
 public:
  RequestNodeDataUploadNtf();
  virtual ~RequestNodeDataUploadNtf();

  RequestNodeDataUploadNtf(const RequestNodeDataUploadNtf& from);

  inline RequestNodeDataUploadNtf& operator=(const RequestNodeDataUploadNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestNodeDataUploadNtf& default_instance();

  void Swap(RequestNodeDataUploadNtf* other);

  // implements Message ----------------------------------------------

  RequestNodeDataUploadNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestNodeDataUploadNtf& from);
  void MergeFrom(const RequestNodeDataUploadNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required .DataType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::DataType type() const;
  inline void set_type(::DataType value);

  // repeated .SensorData data = 3;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::SensorData& data(int index) const;
  inline ::SensorData* mutable_data(int index);
  inline ::SensorData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::SensorData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::SensorData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:RequestNodeDataUploadNtf)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  ::google::protobuf::RepeatedPtrField< ::SensorData > data_;
  int type_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static RequestNodeDataUploadNtf* default_instance_;
};
// -------------------------------------------------------------------

class SensorData : public ::google::protobuf::Message {
 public:
  SensorData();
  virtual ~SensorData();

  SensorData(const SensorData& from);

  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorData& default_instance();

  void Swap(SensorData* other);

  // implements Message ----------------------------------------------

  SensorData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorData& from);
  void MergeFrom(const SensorData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sensor_no = 1;
  inline bool has_sensor_no() const;
  inline void clear_sensor_no();
  static const int kSensorNoFieldNumber = 1;
  inline ::google::protobuf::uint32 sensor_no() const;
  inline void set_sensor_no(::google::protobuf::uint32 value);

  // required uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required float data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline float data() const;
  inline void set_data(float value);

  // optional float reserved = 4;
  inline bool has_reserved() const;
  inline void clear_reserved();
  static const int kReservedFieldNumber = 4;
  inline float reserved() const;
  inline void set_reserved(float value);

  // required uint64 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SensorData)
 private:
  inline void set_has_sensor_no();
  inline void clear_has_sensor_no();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_reserved();
  inline void clear_has_reserved();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 sensor_no_;
  ::google::protobuf::uint32 type_;
  float data_;
  float reserved_;
  ::google::protobuf::uint64 time_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static SensorData* default_instance_;
};
// -------------------------------------------------------------------

class NmpDataUploadNtf : public ::google::protobuf::Message {
 public:
  NmpDataUploadNtf();
  virtual ~NmpDataUploadNtf();

  NmpDataUploadNtf(const NmpDataUploadNtf& from);

  inline NmpDataUploadNtf& operator=(const NmpDataUploadNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NmpDataUploadNtf& default_instance();

  void Swap(NmpDataUploadNtf* other);

  // implements Message ----------------------------------------------

  NmpDataUploadNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NmpDataUploadNtf& from);
  void MergeFrom(const NmpDataUploadNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required bytes nmp_data = 2;
  inline bool has_nmp_data() const;
  inline void clear_nmp_data();
  static const int kNmpDataFieldNumber = 2;
  inline const ::std::string& nmp_data() const;
  inline void set_nmp_data(const ::std::string& value);
  inline void set_nmp_data(const char* value);
  inline void set_nmp_data(const void* value, size_t size);
  inline ::std::string* mutable_nmp_data();
  inline ::std::string* release_nmp_data();
  inline void set_allocated_nmp_data(::std::string* nmp_data);

  // @@protoc_insertion_point(class_scope:NmpDataUploadNtf)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_nmp_data();
  inline void clear_has_nmp_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  ::std::string* nmp_data_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static NmpDataUploadNtf* default_instance_;
};
// -------------------------------------------------------------------

class ContinueNtf : public ::google::protobuf::Message {
 public:
  ContinueNtf();
  virtual ~ContinueNtf();

  ContinueNtf(const ContinueNtf& from);

  inline ContinueNtf& operator=(const ContinueNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContinueNtf& default_instance();

  void Swap(ContinueNtf* other);

  // implements Message ----------------------------------------------

  ContinueNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContinueNtf& from);
  void MergeFrom(const ContinueNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seq = 1;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 1;
  inline ::google::protobuf::uint32 seq() const;
  inline void set_seq(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ContinueNtf)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 seq_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static ContinueNtf* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeRealDataRqst : public ::google::protobuf::Message {
 public:
  GetNodeRealDataRqst();
  virtual ~GetNodeRealDataRqst();

  GetNodeRealDataRqst(const GetNodeRealDataRqst& from);

  inline GetNodeRealDataRqst& operator=(const GetNodeRealDataRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeRealDataRqst& default_instance();

  void Swap(GetNodeRealDataRqst* other);

  // implements Message ----------------------------------------------

  GetNodeRealDataRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeRealDataRqst& from);
  void MergeFrom(const GetNodeRealDataRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required uint32 sensor_no = 2;
  inline bool has_sensor_no() const;
  inline void clear_sensor_no();
  static const int kSensorNoFieldNumber = 2;
  inline ::google::protobuf::uint32 sensor_no() const;
  inline void set_sensor_no(::google::protobuf::uint32 value);

  // required uint32 timeout = 3;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 3;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GetNodeRealDataRqst)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_sensor_no();
  inline void clear_has_sensor_no();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  ::google::protobuf::uint32 sensor_no_;
  ::google::protobuf::uint32 timeout_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetNodeRealDataRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeRealDataRsps : public ::google::protobuf::Message {
 public:
  GetNodeRealDataRsps();
  virtual ~GetNodeRealDataRsps();

  GetNodeRealDataRsps(const GetNodeRealDataRsps& from);

  inline GetNodeRealDataRsps& operator=(const GetNodeRealDataRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeRealDataRsps& default_instance();

  void Swap(GetNodeRealDataRsps* other);

  // implements Message ----------------------------------------------

  GetNodeRealDataRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeRealDataRsps& from);
  void MergeFrom(const GetNodeRealDataRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required .DataType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::DataType type() const;
  inline void set_type(::DataType value);

  // repeated .SensorData s_data = 3;
  inline int s_data_size() const;
  inline void clear_s_data();
  static const int kSDataFieldNumber = 3;
  inline const ::SensorData& s_data(int index) const;
  inline ::SensorData* mutable_s_data(int index);
  inline ::SensorData* add_s_data();
  inline const ::google::protobuf::RepeatedPtrField< ::SensorData >&
      s_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::SensorData >*
      mutable_s_data();

  // @@protoc_insertion_point(class_scope:GetNodeRealDataRsps)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  ::google::protobuf::RepeatedPtrField< ::SensorData > s_data_;
  int type_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetNodeRealDataRsps* default_instance_;
};
// -------------------------------------------------------------------

class SetCommandToNodeRqst : public ::google::protobuf::Message {
 public:
  SetCommandToNodeRqst();
  virtual ~SetCommandToNodeRqst();

  SetCommandToNodeRqst(const SetCommandToNodeRqst& from);

  inline SetCommandToNodeRqst& operator=(const SetCommandToNodeRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetCommandToNodeRqst& default_instance();

  void Swap(SetCommandToNodeRqst* other);

  // implements Message ----------------------------------------------

  SetCommandToNodeRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetCommandToNodeRqst& from);
  void MergeFrom(const SetCommandToNodeRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SetCommandToNodeRqst_Command Command;
  static const Command ON_OFF = SetCommandToNodeRqst_Command_ON_OFF;
  static const Command SET_THRESHOLD = SetCommandToNodeRqst_Command_SET_THRESHOLD;
  static const Command SET_INTERVAL = SetCommandToNodeRqst_Command_SET_INTERVAL;
  static const Command DATA_SWITCH = SetCommandToNodeRqst_Command_DATA_SWITCH;
  static inline bool Command_IsValid(int value) {
    return SetCommandToNodeRqst_Command_IsValid(value);
  }
  static const Command Command_MIN =
    SetCommandToNodeRqst_Command_Command_MIN;
  static const Command Command_MAX =
    SetCommandToNodeRqst_Command_Command_MAX;
  static const int Command_ARRAYSIZE =
    SetCommandToNodeRqst_Command_Command_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Command_descriptor() {
    return SetCommandToNodeRqst_Command_descriptor();
  }
  static inline const ::std::string& Command_Name(Command value) {
    return SetCommandToNodeRqst_Command_Name(value);
  }
  static inline bool Command_Parse(const ::std::string& name,
      Command* value) {
    return SetCommandToNodeRqst_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required .SetCommandToNodeRqst.Command cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline ::SetCommandToNodeRqst_Command cmd() const;
  inline void set_cmd(::SetCommandToNodeRqst_Command value);

  // optional uint32 sub_type = 3;
  inline bool has_sub_type() const;
  inline void clear_sub_type();
  static const int kSubTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 sub_type() const;
  inline void set_sub_type(::google::protobuf::uint32 value);

  // optional .TypeData node_data = 4;
  inline bool has_node_data() const;
  inline void clear_node_data();
  static const int kNodeDataFieldNumber = 4;
  inline const ::TypeData& node_data() const;
  inline ::TypeData* mutable_node_data();
  inline ::TypeData* release_node_data();
  inline void set_allocated_node_data(::TypeData* node_data);

  // repeated .SensorTypeData sensor_data_list = 5;
  inline int sensor_data_list_size() const;
  inline void clear_sensor_data_list();
  static const int kSensorDataListFieldNumber = 5;
  inline const ::SensorTypeData& sensor_data_list(int index) const;
  inline ::SensorTypeData* mutable_sensor_data_list(int index);
  inline ::SensorTypeData* add_sensor_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::SensorTypeData >&
      sensor_data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::SensorTypeData >*
      mutable_sensor_data_list();

  // @@protoc_insertion_point(class_scope:SetCommandToNodeRqst)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_sub_type();
  inline void clear_has_sub_type();
  inline void set_has_node_data();
  inline void clear_has_node_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  int cmd_;
  ::google::protobuf::uint32 sub_type_;
  ::TypeData* node_data_;
  ::google::protobuf::RepeatedPtrField< ::SensorTypeData > sensor_data_list_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static SetCommandToNodeRqst* default_instance_;
};
// -------------------------------------------------------------------

class TypeData : public ::google::protobuf::Message {
 public:
  TypeData();
  virtual ~TypeData();

  TypeData(const TypeData& from);

  inline TypeData& operator=(const TypeData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TypeData& default_instance();

  void Swap(TypeData* other);

  // implements Message ----------------------------------------------

  TypeData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TypeData& from);
  void MergeFrom(const TypeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required float data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline float data() const;
  inline void set_data(float value);

  // @@protoc_insertion_point(class_scope:TypeData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 type_;
  float data_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static TypeData* default_instance_;
};
// -------------------------------------------------------------------

class SensorTypeData : public ::google::protobuf::Message {
 public:
  SensorTypeData();
  virtual ~SensorTypeData();

  SensorTypeData(const SensorTypeData& from);

  inline SensorTypeData& operator=(const SensorTypeData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorTypeData& default_instance();

  void Swap(SensorTypeData* other);

  // implements Message ----------------------------------------------

  SensorTypeData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorTypeData& from);
  void MergeFrom(const SensorTypeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sensor_no = 1;
  inline bool has_sensor_no() const;
  inline void clear_sensor_no();
  static const int kSensorNoFieldNumber = 1;
  inline ::google::protobuf::uint32 sensor_no() const;
  inline void set_sensor_no(::google::protobuf::uint32 value);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required float data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline float data() const;
  inline void set_data(float value);

  // @@protoc_insertion_point(class_scope:SensorTypeData)
 private:
  inline void set_has_sensor_no();
  inline void clear_has_sensor_no();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 sensor_no_;
  ::google::protobuf::uint32 type_;
  float data_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static SensorTypeData* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeSettingsRqst : public ::google::protobuf::Message {
 public:
  GetNodeSettingsRqst();
  virtual ~GetNodeSettingsRqst();

  GetNodeSettingsRqst(const GetNodeSettingsRqst& from);

  inline GetNodeSettingsRqst& operator=(const GetNodeSettingsRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeSettingsRqst& default_instance();

  void Swap(GetNodeSettingsRqst* other);

  // implements Message ----------------------------------------------

  GetNodeSettingsRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeSettingsRqst& from);
  void MergeFrom(const GetNodeSettingsRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GetNodeSettingsRqst_Command Command;
  static const Command GET_ON_OFF = GetNodeSettingsRqst_Command_GET_ON_OFF;
  static const Command GET_THRESHOLD = GetNodeSettingsRqst_Command_GET_THRESHOLD;
  static const Command GET_INTERVAL = GetNodeSettingsRqst_Command_GET_INTERVAL;
  static inline bool Command_IsValid(int value) {
    return GetNodeSettingsRqst_Command_IsValid(value);
  }
  static const Command Command_MIN =
    GetNodeSettingsRqst_Command_Command_MIN;
  static const Command Command_MAX =
    GetNodeSettingsRqst_Command_Command_MAX;
  static const int Command_ARRAYSIZE =
    GetNodeSettingsRqst_Command_Command_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Command_descriptor() {
    return GetNodeSettingsRqst_Command_descriptor();
  }
  static inline const ::std::string& Command_Name(Command value) {
    return GetNodeSettingsRqst_Command_Name(value);
  }
  static inline bool Command_Parse(const ::std::string& name,
      Command* value) {
    return GetNodeSettingsRqst_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required .GetNodeSettingsRqst.Command cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline ::GetNodeSettingsRqst_Command cmd() const;
  inline void set_cmd(::GetNodeSettingsRqst_Command value);

  // optional uint32 sub_type = 3;
  inline bool has_sub_type() const;
  inline void clear_sub_type();
  static const int kSubTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 sub_type() const;
  inline void set_sub_type(::google::protobuf::uint32 value);

  // required uint32 sensor_no = 4;
  inline bool has_sensor_no() const;
  inline void clear_sensor_no();
  static const int kSensorNoFieldNumber = 4;
  inline ::google::protobuf::uint32 sensor_no() const;
  inline void set_sensor_no(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GetNodeSettingsRqst)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_sub_type();
  inline void clear_has_sub_type();
  inline void set_has_sensor_no();
  inline void clear_has_sensor_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  int cmd_;
  ::google::protobuf::uint32 sub_type_;
  ::google::protobuf::uint32 sensor_no_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetNodeSettingsRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetNodeSettingsRsps : public ::google::protobuf::Message {
 public:
  GetNodeSettingsRsps();
  virtual ~GetNodeSettingsRsps();

  GetNodeSettingsRsps(const GetNodeSettingsRsps& from);

  inline GetNodeSettingsRsps& operator=(const GetNodeSettingsRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeSettingsRsps& default_instance();

  void Swap(GetNodeSettingsRsps* other);

  // implements Message ----------------------------------------------

  GetNodeSettingsRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNodeSettingsRsps& from);
  void MergeFrom(const GetNodeSettingsRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TypeData node_data = 1;
  inline bool has_node_data() const;
  inline void clear_node_data();
  static const int kNodeDataFieldNumber = 1;
  inline const ::TypeData& node_data() const;
  inline ::TypeData* mutable_node_data();
  inline ::TypeData* release_node_data();
  inline void set_allocated_node_data(::TypeData* node_data);

  // repeated .SensorTypeData sensor_data_list = 2;
  inline int sensor_data_list_size() const;
  inline void clear_sensor_data_list();
  static const int kSensorDataListFieldNumber = 2;
  inline const ::SensorTypeData& sensor_data_list(int index) const;
  inline ::SensorTypeData* mutable_sensor_data_list(int index);
  inline ::SensorTypeData* add_sensor_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::SensorTypeData >&
      sensor_data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::SensorTypeData >*
      mutable_sensor_data_list();

  // @@protoc_insertion_point(class_scope:GetNodeSettingsRsps)
 private:
  inline void set_has_node_data();
  inline void clear_has_node_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::TypeData* node_data_;
  ::google::protobuf::RepeatedPtrField< ::SensorTypeData > sensor_data_list_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetNodeSettingsRsps* default_instance_;
};
// -------------------------------------------------------------------

class GetUpDisconCachedAlarmRqst : public ::google::protobuf::Message {
 public:
  GetUpDisconCachedAlarmRqst();
  virtual ~GetUpDisconCachedAlarmRqst();

  GetUpDisconCachedAlarmRqst(const GetUpDisconCachedAlarmRqst& from);

  inline GetUpDisconCachedAlarmRqst& operator=(const GetUpDisconCachedAlarmRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUpDisconCachedAlarmRqst& default_instance();

  void Swap(GetUpDisconCachedAlarmRqst* other);

  // implements Message ----------------------------------------------

  GetUpDisconCachedAlarmRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUpDisconCachedAlarmRqst& from);
  void MergeFrom(const GetUpDisconCachedAlarmRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 begin_time = 1;
  inline bool has_begin_time() const;
  inline void clear_begin_time();
  static const int kBeginTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 begin_time() const;
  inline void set_begin_time(::google::protobuf::uint64 value);

  // required uint64 end_time = 2;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 end_time() const;
  inline void set_end_time(::google::protobuf::uint64 value);

  // required uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GetUpDisconCachedAlarmRqst)
 private:
  inline void set_has_begin_time();
  inline void clear_has_begin_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 begin_time_;
  ::google::protobuf::uint64 end_time_;
  ::google::protobuf::uint32 count_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetUpDisconCachedAlarmRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetUpDisconCachedAlarmRsps : public ::google::protobuf::Message {
 public:
  GetUpDisconCachedAlarmRsps();
  virtual ~GetUpDisconCachedAlarmRsps();

  GetUpDisconCachedAlarmRsps(const GetUpDisconCachedAlarmRsps& from);

  inline GetUpDisconCachedAlarmRsps& operator=(const GetUpDisconCachedAlarmRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUpDisconCachedAlarmRsps& default_instance();

  void Swap(GetUpDisconCachedAlarmRsps* other);

  // implements Message ----------------------------------------------

  GetUpDisconCachedAlarmRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUpDisconCachedAlarmRsps& from);
  void MergeFrom(const GetUpDisconCachedAlarmRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CachedAlarmData data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::CachedAlarmData& data(int index) const;
  inline ::CachedAlarmData* mutable_data(int index);
  inline ::CachedAlarmData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::CachedAlarmData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::CachedAlarmData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:GetUpDisconCachedAlarmRsps)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CachedAlarmData > data_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetUpDisconCachedAlarmRsps* default_instance_;
};
// -------------------------------------------------------------------

class CachedAlarmData : public ::google::protobuf::Message {
 public:
  CachedAlarmData();
  virtual ~CachedAlarmData();

  CachedAlarmData(const CachedAlarmData& from);

  inline CachedAlarmData& operator=(const CachedAlarmData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CachedAlarmData& default_instance();

  void Swap(CachedAlarmData* other);

  // implements Message ----------------------------------------------

  CachedAlarmData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CachedAlarmData& from);
  void MergeFrom(const CachedAlarmData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required uint32 sensor_no = 2;
  inline bool has_sensor_no() const;
  inline void clear_sensor_no();
  static const int kSensorNoFieldNumber = 2;
  inline ::google::protobuf::uint32 sensor_no() const;
  inline void set_sensor_no(::google::protobuf::uint32 value);

  // required .DataType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::DataType type() const;
  inline void set_type(::DataType value);

  // required float data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline float data() const;
  inline void set_data(float value);

  // optional uint32 reserved = 5;
  inline bool has_reserved() const;
  inline void clear_reserved();
  static const int kReservedFieldNumber = 5;
  inline ::google::protobuf::uint32 reserved() const;
  inline void set_reserved(::google::protobuf::uint32 value);

  // required uint64 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CachedAlarmData)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_sensor_no();
  inline void clear_has_sensor_no();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_reserved();
  inline void clear_has_reserved();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  ::google::protobuf::uint32 sensor_no_;
  int type_;
  float data_;
  ::google::protobuf::uint32 reserved_;
  ::google::protobuf::uint64 time_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static CachedAlarmData* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeAllNodeDataRqst : public ::google::protobuf::Message {
 public:
  SubscribeAllNodeDataRqst();
  virtual ~SubscribeAllNodeDataRqst();

  SubscribeAllNodeDataRqst(const SubscribeAllNodeDataRqst& from);

  inline SubscribeAllNodeDataRqst& operator=(const SubscribeAllNodeDataRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeAllNodeDataRqst& default_instance();

  void Swap(SubscribeAllNodeDataRqst* other);

  // implements Message ----------------------------------------------

  SubscribeAllNodeDataRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeAllNodeDataRqst& from);
  void MergeFrom(const SubscribeAllNodeDataRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DataType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::DataType type() const;
  inline void set_type(::DataType value);

  // @@protoc_insertion_point(class_scope:SubscribeAllNodeDataRqst)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static SubscribeAllNodeDataRqst* default_instance_;
};
// -------------------------------------------------------------------

class CancelAllNodeDataRqst : public ::google::protobuf::Message {
 public:
  CancelAllNodeDataRqst();
  virtual ~CancelAllNodeDataRqst();

  CancelAllNodeDataRqst(const CancelAllNodeDataRqst& from);

  inline CancelAllNodeDataRqst& operator=(const CancelAllNodeDataRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelAllNodeDataRqst& default_instance();

  void Swap(CancelAllNodeDataRqst* other);

  // implements Message ----------------------------------------------

  CancelAllNodeDataRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelAllNodeDataRqst& from);
  void MergeFrom(const CancelAllNodeDataRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DataType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::DataType type() const;
  inline void set_type(::DataType value);

  // @@protoc_insertion_point(class_scope:CancelAllNodeDataRqst)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static CancelAllNodeDataRqst* default_instance_;
};
// -------------------------------------------------------------------

class BatSubscribeNodeDataRqst : public ::google::protobuf::Message {
 public:
  BatSubscribeNodeDataRqst();
  virtual ~BatSubscribeNodeDataRqst();

  BatSubscribeNodeDataRqst(const BatSubscribeNodeDataRqst& from);

  inline BatSubscribeNodeDataRqst& operator=(const BatSubscribeNodeDataRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatSubscribeNodeDataRqst& default_instance();

  void Swap(BatSubscribeNodeDataRqst* other);

  // implements Message ----------------------------------------------

  BatSubscribeNodeDataRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatSubscribeNodeDataRqst& from);
  void MergeFrom(const BatSubscribeNodeDataRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DataType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::DataType type() const;
  inline void set_type(::DataType value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated bytes node_id = 3;
  inline int node_id_size() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 3;
  inline const ::std::string& node_id(int index) const;
  inline ::std::string* mutable_node_id(int index);
  inline void set_node_id(int index, const ::std::string& value);
  inline void set_node_id(int index, const char* value);
  inline void set_node_id(int index, const void* value, size_t size);
  inline ::std::string* add_node_id();
  inline void add_node_id(const ::std::string& value);
  inline void add_node_id(const char* value);
  inline void add_node_id(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& node_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_node_id();

  // @@protoc_insertion_point(class_scope:BatSubscribeNodeDataRqst)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::RepeatedPtrField< ::std::string> node_id_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static BatSubscribeNodeDataRqst* default_instance_;
};
// -------------------------------------------------------------------

class BatCancelNodeDataRqst : public ::google::protobuf::Message {
 public:
  BatCancelNodeDataRqst();
  virtual ~BatCancelNodeDataRqst();

  BatCancelNodeDataRqst(const BatCancelNodeDataRqst& from);

  inline BatCancelNodeDataRqst& operator=(const BatCancelNodeDataRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatCancelNodeDataRqst& default_instance();

  void Swap(BatCancelNodeDataRqst* other);

  // implements Message ----------------------------------------------

  BatCancelNodeDataRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatCancelNodeDataRqst& from);
  void MergeFrom(const BatCancelNodeDataRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DataType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::DataType type() const;
  inline void set_type(::DataType value);

  // required uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated bytes node_id = 3;
  inline int node_id_size() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 3;
  inline const ::std::string& node_id(int index) const;
  inline ::std::string* mutable_node_id(int index);
  inline void set_node_id(int index, const ::std::string& value);
  inline void set_node_id(int index, const char* value);
  inline void set_node_id(int index, const void* value, size_t size);
  inline ::std::string* add_node_id();
  inline void add_node_id(const ::std::string& value);
  inline void add_node_id(const char* value);
  inline void add_node_id(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& node_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_node_id();

  // @@protoc_insertion_point(class_scope:BatCancelNodeDataRqst)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::RepeatedPtrField< ::std::string> node_id_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static BatCancelNodeDataRqst* default_instance_;
};
// -------------------------------------------------------------------

class BlackWhiteNodeRqst : public ::google::protobuf::Message {
 public:
  BlackWhiteNodeRqst();
  virtual ~BlackWhiteNodeRqst();

  BlackWhiteNodeRqst(const BlackWhiteNodeRqst& from);

  inline BlackWhiteNodeRqst& operator=(const BlackWhiteNodeRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlackWhiteNodeRqst& default_instance();

  void Swap(BlackWhiteNodeRqst* other);

  // implements Message ----------------------------------------------

  BlackWhiteNodeRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlackWhiteNodeRqst& from);
  void MergeFrom(const BlackWhiteNodeRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BlackWhiteNodeRqst_Command Command;
  static const Command ADD = BlackWhiteNodeRqst_Command_ADD;
  static const Command DEL = BlackWhiteNodeRqst_Command_DEL;
  static inline bool Command_IsValid(int value) {
    return BlackWhiteNodeRqst_Command_IsValid(value);
  }
  static const Command Command_MIN =
    BlackWhiteNodeRqst_Command_Command_MIN;
  static const Command Command_MAX =
    BlackWhiteNodeRqst_Command_Command_MAX;
  static const int Command_ARRAYSIZE =
    BlackWhiteNodeRqst_Command_Command_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Command_descriptor() {
    return BlackWhiteNodeRqst_Command_descriptor();
  }
  static inline const ::std::string& Command_Name(Command value) {
    return BlackWhiteNodeRqst_Command_Name(value);
  }
  static inline bool Command_Parse(const ::std::string& name,
      Command* value) {
    return BlackWhiteNodeRqst_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .NodeType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::NodeType type() const;
  inline void set_type(::NodeType value);

  // required .BlackWhiteNodeRqst.Command cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline ::BlackWhiteNodeRqst_Command cmd() const;
  inline void set_cmd(::BlackWhiteNodeRqst_Command value);

  // repeated string node_id = 3;
  inline int node_id_size() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 3;
  inline const ::std::string& node_id(int index) const;
  inline ::std::string* mutable_node_id(int index);
  inline void set_node_id(int index, const ::std::string& value);
  inline void set_node_id(int index, const char* value);
  inline void set_node_id(int index, const char* value, size_t size);
  inline ::std::string* add_node_id();
  inline void add_node_id(const ::std::string& value);
  inline void add_node_id(const char* value);
  inline void add_node_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& node_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_node_id();

  // @@protoc_insertion_point(class_scope:BlackWhiteNodeRqst)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  int cmd_;
  ::google::protobuf::RepeatedPtrField< ::std::string> node_id_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static BlackWhiteNodeRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetBlackWhiteRqst : public ::google::protobuf::Message {
 public:
  GetBlackWhiteRqst();
  virtual ~GetBlackWhiteRqst();

  GetBlackWhiteRqst(const GetBlackWhiteRqst& from);

  inline GetBlackWhiteRqst& operator=(const GetBlackWhiteRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlackWhiteRqst& default_instance();

  void Swap(GetBlackWhiteRqst* other);

  // implements Message ----------------------------------------------

  GetBlackWhiteRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBlackWhiteRqst& from);
  void MergeFrom(const GetBlackWhiteRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NodeType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::NodeType type() const;
  inline void set_type(::NodeType value);

  // @@protoc_insertion_point(class_scope:GetBlackWhiteRqst)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetBlackWhiteRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetBlackWhiteRsps : public ::google::protobuf::Message {
 public:
  GetBlackWhiteRsps();
  virtual ~GetBlackWhiteRsps();

  GetBlackWhiteRsps(const GetBlackWhiteRsps& from);

  inline GetBlackWhiteRsps& operator=(const GetBlackWhiteRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBlackWhiteRsps& default_instance();

  void Swap(GetBlackWhiteRsps* other);

  // implements Message ----------------------------------------------

  GetBlackWhiteRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBlackWhiteRsps& from);
  void MergeFrom(const GetBlackWhiteRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated string node_id = 2;
  inline int node_id_size() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  inline const ::std::string& node_id(int index) const;
  inline ::std::string* mutable_node_id(int index);
  inline void set_node_id(int index, const ::std::string& value);
  inline void set_node_id(int index, const char* value);
  inline void set_node_id(int index, const char* value, size_t size);
  inline ::std::string* add_node_id();
  inline void add_node_id(const ::std::string& value);
  inline void add_node_id(const char* value);
  inline void add_node_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& node_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_node_id();

  // @@protoc_insertion_point(class_scope:GetBlackWhiteRsps)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> node_id_;
  ::google::protobuf::uint32 count_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetBlackWhiteRsps* default_instance_;
};
// -------------------------------------------------------------------

class DownloadFirmwareRqst : public ::google::protobuf::Message {
 public:
  DownloadFirmwareRqst();
  virtual ~DownloadFirmwareRqst();

  DownloadFirmwareRqst(const DownloadFirmwareRqst& from);

  inline DownloadFirmwareRqst& operator=(const DownloadFirmwareRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DownloadFirmwareRqst& default_instance();

  void Swap(DownloadFirmwareRqst* other);

  // implements Message ----------------------------------------------

  DownloadFirmwareRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DownloadFirmwareRqst& from);
  void MergeFrom(const DownloadFirmwareRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:DownloadFirmwareRqst)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  ::std::string* url_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static DownloadFirmwareRqst* default_instance_;
};
// -------------------------------------------------------------------

class DownloadFirmwareRsps : public ::google::protobuf::Message {
 public:
  DownloadFirmwareRsps();
  virtual ~DownloadFirmwareRsps();

  DownloadFirmwareRsps(const DownloadFirmwareRsps& from);

  inline DownloadFirmwareRsps& operator=(const DownloadFirmwareRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DownloadFirmwareRsps& default_instance();

  void Swap(DownloadFirmwareRsps* other);

  // implements Message ----------------------------------------------

  DownloadFirmwareRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DownloadFirmwareRsps& from);
  void MergeFrom(const DownloadFirmwareRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReceiveStatus receive_status = 1;
  inline bool has_receive_status() const;
  inline void clear_receive_status();
  static const int kReceiveStatusFieldNumber = 1;
  inline ::ReceiveStatus receive_status() const;
  inline void set_receive_status(::ReceiveStatus value);

  // @@protoc_insertion_point(class_scope:DownloadFirmwareRsps)
 private:
  inline void set_has_receive_status();
  inline void clear_has_receive_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int receive_status_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static DownloadFirmwareRsps* default_instance_;
};
// -------------------------------------------------------------------

class DownloadFirmwareNtf : public ::google::protobuf::Message {
 public:
  DownloadFirmwareNtf();
  virtual ~DownloadFirmwareNtf();

  DownloadFirmwareNtf(const DownloadFirmwareNtf& from);

  inline DownloadFirmwareNtf& operator=(const DownloadFirmwareNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DownloadFirmwareNtf& default_instance();

  void Swap(DownloadFirmwareNtf* other);

  // implements Message ----------------------------------------------

  DownloadFirmwareNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DownloadFirmwareNtf& from);
  void MergeFrom(const DownloadFirmwareNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seq = 1;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 1;
  inline ::google::protobuf::uint32 seq() const;
  inline void set_seq(::google::protobuf::uint32 value);

  // required .ExecuteStatus execute_status = 2;
  inline bool has_execute_status() const;
  inline void clear_execute_status();
  static const int kExecuteStatusFieldNumber = 2;
  inline ::ExecuteStatus execute_status() const;
  inline void set_execute_status(::ExecuteStatus value);

  // @@protoc_insertion_point(class_scope:DownloadFirmwareNtf)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_execute_status();
  inline void clear_has_execute_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 seq_;
  int execute_status_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static DownloadFirmwareNtf* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeModuleRqst : public ::google::protobuf::Message {
 public:
  UpgradeModuleRqst();
  virtual ~UpgradeModuleRqst();

  UpgradeModuleRqst(const UpgradeModuleRqst& from);

  inline UpgradeModuleRqst& operator=(const UpgradeModuleRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeModuleRqst& default_instance();

  void Swap(UpgradeModuleRqst* other);

  // implements Message ----------------------------------------------

  UpgradeModuleRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpgradeModuleRqst& from);
  void MergeFrom(const UpgradeModuleRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string module_name = 1;
  inline bool has_module_name() const;
  inline void clear_module_name();
  static const int kModuleNameFieldNumber = 1;
  inline const ::std::string& module_name() const;
  inline void set_module_name(const ::std::string& value);
  inline void set_module_name(const char* value);
  inline void set_module_name(const char* value, size_t size);
  inline ::std::string* mutable_module_name();
  inline ::std::string* release_module_name();
  inline void set_allocated_module_name(::std::string* module_name);

  // @@protoc_insertion_point(class_scope:UpgradeModuleRqst)
 private:
  inline void set_has_module_name();
  inline void clear_has_module_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* module_name_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static UpgradeModuleRqst* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeModuleRsps : public ::google::protobuf::Message {
 public:
  UpgradeModuleRsps();
  virtual ~UpgradeModuleRsps();

  UpgradeModuleRsps(const UpgradeModuleRsps& from);

  inline UpgradeModuleRsps& operator=(const UpgradeModuleRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeModuleRsps& default_instance();

  void Swap(UpgradeModuleRsps* other);

  // implements Message ----------------------------------------------

  UpgradeModuleRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpgradeModuleRsps& from);
  void MergeFrom(const UpgradeModuleRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReceiveStatus receive_status = 1;
  inline bool has_receive_status() const;
  inline void clear_receive_status();
  static const int kReceiveStatusFieldNumber = 1;
  inline ::ReceiveStatus receive_status() const;
  inline void set_receive_status(::ReceiveStatus value);

  // @@protoc_insertion_point(class_scope:UpgradeModuleRsps)
 private:
  inline void set_has_receive_status();
  inline void clear_has_receive_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int receive_status_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static UpgradeModuleRsps* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeModuleNtf : public ::google::protobuf::Message {
 public:
  UpgradeModuleNtf();
  virtual ~UpgradeModuleNtf();

  UpgradeModuleNtf(const UpgradeModuleNtf& from);

  inline UpgradeModuleNtf& operator=(const UpgradeModuleNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeModuleNtf& default_instance();

  void Swap(UpgradeModuleNtf* other);

  // implements Message ----------------------------------------------

  UpgradeModuleNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpgradeModuleNtf& from);
  void MergeFrom(const UpgradeModuleNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 seq = 1;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 1;
  inline ::google::protobuf::uint32 seq() const;
  inline void set_seq(::google::protobuf::uint32 value);

  // required .ExecuteStatus execute_status = 2;
  inline bool has_execute_status() const;
  inline void clear_execute_status();
  static const int kExecuteStatusFieldNumber = 2;
  inline ::ExecuteStatus execute_status() const;
  inline void set_execute_status(::ExecuteStatus value);

  // @@protoc_insertion_point(class_scope:UpgradeModuleNtf)
 private:
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_execute_status();
  inline void clear_has_execute_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 seq_;
  int execute_status_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static UpgradeModuleNtf* default_instance_;
};
// -------------------------------------------------------------------

class TerminalPort : public ::google::protobuf::Message {
 public:
  TerminalPort();
  virtual ~TerminalPort();

  TerminalPort(const TerminalPort& from);

  inline TerminalPort& operator=(const TerminalPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TerminalPort& default_instance();

  void Swap(TerminalPort* other);

  // implements Message ----------------------------------------------

  TerminalPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TerminalPort& from);
  void MergeFrom(const TerminalPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port_num = 1;
  inline bool has_port_num() const;
  inline void clear_port_num();
  static const int kPortNumFieldNumber = 1;
  inline ::google::protobuf::uint32 port_num() const;
  inline void set_port_num(::google::protobuf::uint32 value);

  // required uint32 cmd_type = 2;
  inline bool has_cmd_type() const;
  inline void clear_cmd_type();
  static const int kCmdTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 cmd_type() const;
  inline void set_cmd_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TerminalPort)
 private:
  inline void set_has_port_num();
  inline void clear_has_port_num();
  inline void set_has_cmd_type();
  inline void clear_has_cmd_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 port_num_;
  ::google::protobuf::uint32 cmd_type_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static TerminalPort* default_instance_;
};
// -------------------------------------------------------------------

class TerminalStatus : public ::google::protobuf::Message {
 public:
  TerminalStatus();
  virtual ~TerminalStatus();

  TerminalStatus(const TerminalStatus& from);

  inline TerminalStatus& operator=(const TerminalStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TerminalStatus& default_instance();

  void Swap(TerminalStatus* other);

  // implements Message ----------------------------------------------

  TerminalStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TerminalStatus& from);
  void MergeFrom(const TerminalStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port_num = 1;
  inline bool has_port_num() const;
  inline void clear_port_num();
  static const int kPortNumFieldNumber = 1;
  inline ::google::protobuf::uint32 port_num() const;
  inline void set_port_num(::google::protobuf::uint32 value);

  // required uint32 cmd_type = 2;
  inline bool has_cmd_type() const;
  inline void clear_cmd_type();
  static const int kCmdTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 cmd_type() const;
  inline void set_cmd_type(::google::protobuf::uint32 value);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:TerminalStatus)
 private:
  inline void set_has_port_num();
  inline void clear_has_port_num();
  inline void set_has_cmd_type();
  inline void clear_has_cmd_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 port_num_;
  ::google::protobuf::uint32 cmd_type_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static TerminalStatus* default_instance_;
};
// -------------------------------------------------------------------

class GetTerminalStatusRqst : public ::google::protobuf::Message {
 public:
  GetTerminalStatusRqst();
  virtual ~GetTerminalStatusRqst();

  GetTerminalStatusRqst(const GetTerminalStatusRqst& from);

  inline GetTerminalStatusRqst& operator=(const GetTerminalStatusRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTerminalStatusRqst& default_instance();

  void Swap(GetTerminalStatusRqst* other);

  // implements Message ----------------------------------------------

  GetTerminalStatusRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTerminalStatusRqst& from);
  void MergeFrom(const GetTerminalStatusRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // repeated .TerminalPort port = 2;
  inline int port_size() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline const ::TerminalPort& port(int index) const;
  inline ::TerminalPort* mutable_port(int index);
  inline ::TerminalPort* add_port();
  inline const ::google::protobuf::RepeatedPtrField< ::TerminalPort >&
      port() const;
  inline ::google::protobuf::RepeatedPtrField< ::TerminalPort >*
      mutable_port();

  // @@protoc_insertion_point(class_scope:GetTerminalStatusRqst)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  ::google::protobuf::RepeatedPtrField< ::TerminalPort > port_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetTerminalStatusRqst* default_instance_;
};
// -------------------------------------------------------------------

class GetTerminalStatusRsps : public ::google::protobuf::Message {
 public:
  GetTerminalStatusRsps();
  virtual ~GetTerminalStatusRsps();

  GetTerminalStatusRsps(const GetTerminalStatusRsps& from);

  inline GetTerminalStatusRsps& operator=(const GetTerminalStatusRsps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTerminalStatusRsps& default_instance();

  void Swap(GetTerminalStatusRsps* other);

  // implements Message ----------------------------------------------

  GetTerminalStatusRsps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTerminalStatusRsps& from);
  void MergeFrom(const GetTerminalStatusRsps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // repeated .TerminalStatus status = 2;
  inline int status_size() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::TerminalStatus& status(int index) const;
  inline ::TerminalStatus* mutable_status(int index);
  inline ::TerminalStatus* add_status();
  inline const ::google::protobuf::RepeatedPtrField< ::TerminalStatus >&
      status() const;
  inline ::google::protobuf::RepeatedPtrField< ::TerminalStatus >*
      mutable_status();

  // @@protoc_insertion_point(class_scope:GetTerminalStatusRsps)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  ::google::protobuf::RepeatedPtrField< ::TerminalStatus > status_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static GetTerminalStatusRsps* default_instance_;
};
// -------------------------------------------------------------------

class TerminalCmd : public ::google::protobuf::Message {
 public:
  TerminalCmd();
  virtual ~TerminalCmd();

  TerminalCmd(const TerminalCmd& from);

  inline TerminalCmd& operator=(const TerminalCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TerminalCmd& default_instance();

  void Swap(TerminalCmd* other);

  // implements Message ----------------------------------------------

  TerminalCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TerminalCmd& from);
  void MergeFrom(const TerminalCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port_num = 1;
  inline bool has_port_num() const;
  inline void clear_port_num();
  static const int kPortNumFieldNumber = 1;
  inline ::google::protobuf::uint32 port_num() const;
  inline void set_port_num(::google::protobuf::uint32 value);

  // required uint32 cmd_type = 2;
  inline bool has_cmd_type() const;
  inline void clear_cmd_type();
  static const int kCmdTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 cmd_type() const;
  inline void set_cmd_type(::google::protobuf::uint32 value);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:TerminalCmd)
 private:
  inline void set_has_port_num();
  inline void clear_has_port_num();
  inline void set_has_cmd_type();
  inline void clear_has_cmd_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 port_num_;
  ::google::protobuf::uint32 cmd_type_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static TerminalCmd* default_instance_;
};
// -------------------------------------------------------------------

class SetTerminalCtrlCmdRqst : public ::google::protobuf::Message {
 public:
  SetTerminalCtrlCmdRqst();
  virtual ~SetTerminalCtrlCmdRqst();

  SetTerminalCtrlCmdRqst(const SetTerminalCtrlCmdRqst& from);

  inline SetTerminalCtrlCmdRqst& operator=(const SetTerminalCtrlCmdRqst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetTerminalCtrlCmdRqst& default_instance();

  void Swap(SetTerminalCtrlCmdRqst* other);

  // implements Message ----------------------------------------------

  SetTerminalCtrlCmdRqst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetTerminalCtrlCmdRqst& from);
  void MergeFrom(const SetTerminalCtrlCmdRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const char* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // repeated .TerminalCmd cmd_data = 2;
  inline int cmd_data_size() const;
  inline void clear_cmd_data();
  static const int kCmdDataFieldNumber = 2;
  inline const ::TerminalCmd& cmd_data(int index) const;
  inline ::TerminalCmd* mutable_cmd_data(int index);
  inline ::TerminalCmd* add_cmd_data();
  inline const ::google::protobuf::RepeatedPtrField< ::TerminalCmd >&
      cmd_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::TerminalCmd >*
      mutable_cmd_data();

  // @@protoc_insertion_point(class_scope:SetTerminalCtrlCmdRqst)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_id_;
  ::google::protobuf::RepeatedPtrField< ::TerminalCmd > cmd_data_;
  friend void  protobuf_AddDesc_nwpb_2eproto();
  friend void protobuf_AssignDesc_nwpb_2eproto();
  friend void protobuf_ShutdownFile_nwpb_2eproto();

  void InitAsDefaultInstance();
  static SetTerminalCtrlCmdRqst* default_instance_;
};
// ===================================================================


// ===================================================================

// NWPb

// optional .Request rqst = 1;
inline bool NWPb::has_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NWPb::set_has_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NWPb::clear_has_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NWPb::clear_rqst() {
  if (rqst_ != NULL) rqst_->::Request::Clear();
  clear_has_rqst();
}
inline const ::Request& NWPb::rqst() const {
  // @@protoc_insertion_point(field_get:NWPb.rqst)
  return rqst_ != NULL ? *rqst_ : *default_instance_->rqst_;
}
inline ::Request* NWPb::mutable_rqst() {
  set_has_rqst();
  if (rqst_ == NULL) rqst_ = new ::Request;
  // @@protoc_insertion_point(field_mutable:NWPb.rqst)
  return rqst_;
}
inline ::Request* NWPb::release_rqst() {
  clear_has_rqst();
  ::Request* temp = rqst_;
  rqst_ = NULL;
  return temp;
}
inline void NWPb::set_allocated_rqst(::Request* rqst) {
  delete rqst_;
  rqst_ = rqst;
  if (rqst) {
    set_has_rqst();
  } else {
    clear_has_rqst();
  }
  // @@protoc_insertion_point(field_set_allocated:NWPb.rqst)
}

// optional .Response rsps = 2;
inline bool NWPb::has_rsps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NWPb::set_has_rsps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NWPb::clear_has_rsps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NWPb::clear_rsps() {
  if (rsps_ != NULL) rsps_->::Response::Clear();
  clear_has_rsps();
}
inline const ::Response& NWPb::rsps() const {
  // @@protoc_insertion_point(field_get:NWPb.rsps)
  return rsps_ != NULL ? *rsps_ : *default_instance_->rsps_;
}
inline ::Response* NWPb::mutable_rsps() {
  set_has_rsps();
  if (rsps_ == NULL) rsps_ = new ::Response;
  // @@protoc_insertion_point(field_mutable:NWPb.rsps)
  return rsps_;
}
inline ::Response* NWPb::release_rsps() {
  clear_has_rsps();
  ::Response* temp = rsps_;
  rsps_ = NULL;
  return temp;
}
inline void NWPb::set_allocated_rsps(::Response* rsps) {
  delete rsps_;
  rsps_ = rsps;
  if (rsps) {
    set_has_rsps();
  } else {
    clear_has_rsps();
  }
  // @@protoc_insertion_point(field_set_allocated:NWPb.rsps)
}

// optional .Notify ntf = 3;
inline bool NWPb::has_ntf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NWPb::set_has_ntf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NWPb::clear_has_ntf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NWPb::clear_ntf() {
  if (ntf_ != NULL) ntf_->::Notify::Clear();
  clear_has_ntf();
}
inline const ::Notify& NWPb::ntf() const {
  // @@protoc_insertion_point(field_get:NWPb.ntf)
  return ntf_ != NULL ? *ntf_ : *default_instance_->ntf_;
}
inline ::Notify* NWPb::mutable_ntf() {
  set_has_ntf();
  if (ntf_ == NULL) ntf_ = new ::Notify;
  // @@protoc_insertion_point(field_mutable:NWPb.ntf)
  return ntf_;
}
inline ::Notify* NWPb::release_ntf() {
  clear_has_ntf();
  ::Notify* temp = ntf_;
  ntf_ = NULL;
  return temp;
}
inline void NWPb::set_allocated_ntf(::Notify* ntf) {
  delete ntf_;
  ntf_ = ntf;
  if (ntf) {
    set_has_ntf();
  } else {
    clear_has_ntf();
  }
  // @@protoc_insertion_point(field_set_allocated:NWPb.ntf)
}

// -------------------------------------------------------------------

// Request

// required uint32 session = 1;
inline bool Request::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 Request::session() const {
  // @@protoc_insertion_point(field_get:Request.session)
  return session_;
}
inline void Request::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
  // @@protoc_insertion_point(field_set:Request.session)
}

// required uint32 sequence = 2;
inline bool Request::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 Request::sequence() const {
  // @@protoc_insertion_point(field_get:Request.sequence)
  return sequence_;
}
inline void Request::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:Request.sequence)
}

// required .Command command = 3;
inline bool Request::has_command() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_command() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_command() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_command() {
  command_ = 1;
  clear_has_command();
}
inline ::Command Request::command() const {
  // @@protoc_insertion_point(field_get:Request.command)
  return static_cast< ::Command >(command_);
}
inline void Request::set_command(::Command value) {
  assert(::Command_IsValid(value));
  set_has_command();
  command_ = value;
  // @@protoc_insertion_point(field_set:Request.command)
}

// optional bytes content = 4;
inline bool Request::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Request::content() const {
  // @@protoc_insertion_point(field_get:Request.content)
  return *content_;
}
inline void Request::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:Request.content)
}
inline void Request::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:Request.content)
}
inline void Request::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Request.content)
}
inline ::std::string* Request::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Request.content)
  return content_;
}
inline ::std::string* Request::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Request.content)
}

// -------------------------------------------------------------------

// Response

// required uint32 session = 1;
inline bool Response::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 Response::session() const {
  // @@protoc_insertion_point(field_get:Response.session)
  return session_;
}
inline void Response::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
  // @@protoc_insertion_point(field_set:Response.session)
}

// required uint32 sequence = 2;
inline bool Response::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 Response::sequence() const {
  // @@protoc_insertion_point(field_get:Response.sequence)
  return sequence_;
}
inline void Response::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:Response.sequence)
}

// required .Command command = 3;
inline bool Response::has_command() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_command() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_command() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_command() {
  command_ = 1;
  clear_has_command();
}
inline ::Command Response::command() const {
  // @@protoc_insertion_point(field_get:Response.command)
  return static_cast< ::Command >(command_);
}
inline void Response::set_command(::Command value) {
  assert(::Command_IsValid(value));
  set_has_command();
  command_ = value;
  // @@protoc_insertion_point(field_set:Response.command)
}

// required .Response.Error err = 4;
inline bool Response::has_err() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_err() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_err() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_err() {
  err_ = 200;
  clear_has_err();
}
inline ::Response_Error Response::err() const {
  // @@protoc_insertion_point(field_get:Response.err)
  return static_cast< ::Response_Error >(err_);
}
inline void Response::set_err(::Response_Error value) {
  assert(::Response_Error_IsValid(value));
  set_has_err();
  err_ = value;
  // @@protoc_insertion_point(field_set:Response.err)
}

// optional bytes content = 5;
inline bool Response::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Response::content() const {
  // @@protoc_insertion_point(field_get:Response.content)
  return *content_;
}
inline void Response::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:Response.content)
}
inline void Response::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:Response.content)
}
inline void Response::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Response.content)
}
inline ::std::string* Response::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Response.content)
  return content_;
}
inline ::std::string* Response::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Response.content)
}

// -------------------------------------------------------------------

// Notify

// required uint32 session = 1;
inline bool Notify::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notify::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notify::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notify::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 Notify::session() const {
  // @@protoc_insertion_point(field_get:Notify.session)
  return session_;
}
inline void Notify::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
  // @@protoc_insertion_point(field_set:Notify.session)
}

// required .Command command = 2;
inline bool Notify::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Notify::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Notify::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Notify::clear_command() {
  command_ = 1;
  clear_has_command();
}
inline ::Command Notify::command() const {
  // @@protoc_insertion_point(field_get:Notify.command)
  return static_cast< ::Command >(command_);
}
inline void Notify::set_command(::Command value) {
  assert(::Command_IsValid(value));
  set_has_command();
  command_ = value;
  // @@protoc_insertion_point(field_set:Notify.command)
}

// optional bytes content = 3;
inline bool Notify::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Notify::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Notify::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Notify::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Notify::content() const {
  // @@protoc_insertion_point(field_get:Notify.content)
  return *content_;
}
inline void Notify::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:Notify.content)
}
inline void Notify::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:Notify.content)
}
inline void Notify::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Notify.content)
}
inline ::std::string* Notify::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Notify.content)
  return content_;
}
inline ::std::string* Notify::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Notify::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Notify.content)
}

// -------------------------------------------------------------------

// LoginRqst

// required string user_name = 1;
inline bool LoginRqst::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRqst::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRqst::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRqst::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& LoginRqst::user_name() const {
  // @@protoc_insertion_point(field_get:LoginRqst.user_name)
  return *user_name_;
}
inline void LoginRqst::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:LoginRqst.user_name)
}
inline void LoginRqst::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:LoginRqst.user_name)
}
inline void LoginRqst::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LoginRqst.user_name)
}
inline ::std::string* LoginRqst::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:LoginRqst.user_name)
  return user_name_;
}
inline ::std::string* LoginRqst::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRqst::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:LoginRqst.user_name)
}

// required uint32 expires = 2;
inline bool LoginRqst::has_expires() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRqst::set_has_expires() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRqst::clear_has_expires() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRqst::clear_expires() {
  expires_ = 0u;
  clear_has_expires();
}
inline ::google::protobuf::uint32 LoginRqst::expires() const {
  // @@protoc_insertion_point(field_get:LoginRqst.expires)
  return expires_;
}
inline void LoginRqst::set_expires(::google::protobuf::uint32 value) {
  set_has_expires();
  expires_ = value;
  // @@protoc_insertion_point(field_set:LoginRqst.expires)
}

// required .Encrypt encrypt = 3;
inline bool LoginRqst::has_encrypt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRqst::set_has_encrypt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRqst::clear_has_encrypt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRqst::clear_encrypt() {
  encrypt_ = 1;
  clear_has_encrypt();
}
inline ::Encrypt LoginRqst::encrypt() const {
  // @@protoc_insertion_point(field_get:LoginRqst.encrypt)
  return static_cast< ::Encrypt >(encrypt_);
}
inline void LoginRqst::set_encrypt(::Encrypt value) {
  assert(::Encrypt_IsValid(value));
  set_has_encrypt();
  encrypt_ = value;
  // @@protoc_insertion_point(field_set:LoginRqst.encrypt)
}

// required bytes data = 4;
inline bool LoginRqst::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRqst::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRqst::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRqst::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& LoginRqst::data() const {
  // @@protoc_insertion_point(field_get:LoginRqst.data)
  return *data_;
}
inline void LoginRqst::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:LoginRqst.data)
}
inline void LoginRqst::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:LoginRqst.data)
}
inline void LoginRqst::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LoginRqst.data)
}
inline ::std::string* LoginRqst::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:LoginRqst.data)
  return data_;
}
inline ::std::string* LoginRqst::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRqst::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:LoginRqst.data)
}

// -------------------------------------------------------------------

// LoginRsps

// required uint32 session = 1;
inline bool LoginRsps::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRsps::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRsps::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRsps::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 LoginRsps::session() const {
  // @@protoc_insertion_point(field_get:LoginRsps.session)
  return session_;
}
inline void LoginRsps::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
  // @@protoc_insertion_point(field_set:LoginRsps.session)
}

// required uint32 expires = 2;
inline bool LoginRsps::has_expires() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRsps::set_has_expires() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRsps::clear_has_expires() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRsps::clear_expires() {
  expires_ = 0u;
  clear_has_expires();
}
inline ::google::protobuf::uint32 LoginRsps::expires() const {
  // @@protoc_insertion_point(field_get:LoginRsps.expires)
  return expires_;
}
inline void LoginRsps::set_expires(::google::protobuf::uint32 value) {
  set_has_expires();
  expires_ = value;
  // @@protoc_insertion_point(field_set:LoginRsps.expires)
}

// required uint32 nodes = 3;
inline bool LoginRsps::has_nodes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRsps::set_has_nodes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRsps::clear_has_nodes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRsps::clear_nodes() {
  nodes_ = 0u;
  clear_has_nodes();
}
inline ::google::protobuf::uint32 LoginRsps::nodes() const {
  // @@protoc_insertion_point(field_get:LoginRsps.nodes)
  return nodes_;
}
inline void LoginRsps::set_nodes(::google::protobuf::uint32 value) {
  set_has_nodes();
  nodes_ = value;
  // @@protoc_insertion_point(field_set:LoginRsps.nodes)
}

// required uint32 sessions = 4;
inline bool LoginRsps::has_sessions() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRsps::set_has_sessions() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRsps::clear_has_sessions() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRsps::clear_sessions() {
  sessions_ = 0u;
  clear_has_sessions();
}
inline ::google::protobuf::uint32 LoginRsps::sessions() const {
  // @@protoc_insertion_point(field_get:LoginRsps.sessions)
  return sessions_;
}
inline void LoginRsps::set_sessions(::google::protobuf::uint32 value) {
  set_has_sessions();
  sessions_ = value;
  // @@protoc_insertion_point(field_set:LoginRsps.sessions)
}

// required bytes nw_id = 5;
inline bool LoginRsps::has_nw_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginRsps::set_has_nw_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginRsps::clear_has_nw_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginRsps::clear_nw_id() {
  if (nw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_->clear();
  }
  clear_has_nw_id();
}
inline const ::std::string& LoginRsps::nw_id() const {
  // @@protoc_insertion_point(field_get:LoginRsps.nw_id)
  return *nw_id_;
}
inline void LoginRsps::set_nw_id(const ::std::string& value) {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  nw_id_->assign(value);
  // @@protoc_insertion_point(field_set:LoginRsps.nw_id)
}
inline void LoginRsps::set_nw_id(const char* value) {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  nw_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:LoginRsps.nw_id)
}
inline void LoginRsps::set_nw_id(const void* value, size_t size) {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  nw_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LoginRsps.nw_id)
}
inline ::std::string* LoginRsps::mutable_nw_id() {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:LoginRsps.nw_id)
  return nw_id_;
}
inline ::std::string* LoginRsps::release_nw_id() {
  clear_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nw_id_;
    nw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginRsps::set_allocated_nw_id(::std::string* nw_id) {
  if (nw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nw_id_;
  }
  if (nw_id) {
    set_has_nw_id();
    nw_id_ = nw_id;
  } else {
    clear_has_nw_id();
    nw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:LoginRsps.nw_id)
}

// required .Encrypt encrypt = 6;
inline bool LoginRsps::has_encrypt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginRsps::set_has_encrypt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginRsps::clear_has_encrypt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginRsps::clear_encrypt() {
  encrypt_ = 1;
  clear_has_encrypt();
}
inline ::Encrypt LoginRsps::encrypt() const {
  // @@protoc_insertion_point(field_get:LoginRsps.encrypt)
  return static_cast< ::Encrypt >(encrypt_);
}
inline void LoginRsps::set_encrypt(::Encrypt value) {
  assert(::Encrypt_IsValid(value));
  set_has_encrypt();
  encrypt_ = value;
  // @@protoc_insertion_point(field_set:LoginRsps.encrypt)
}

// -------------------------------------------------------------------

// ChangePasswordRqst

// required string old_password = 1;
inline bool ChangePasswordRqst::has_old_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangePasswordRqst::set_has_old_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangePasswordRqst::clear_has_old_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangePasswordRqst::clear_old_password() {
  if (old_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    old_password_->clear();
  }
  clear_has_old_password();
}
inline const ::std::string& ChangePasswordRqst::old_password() const {
  // @@protoc_insertion_point(field_get:ChangePasswordRqst.old_password)
  return *old_password_;
}
inline void ChangePasswordRqst::set_old_password(const ::std::string& value) {
  set_has_old_password();
  if (old_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    old_password_ = new ::std::string;
  }
  old_password_->assign(value);
  // @@protoc_insertion_point(field_set:ChangePasswordRqst.old_password)
}
inline void ChangePasswordRqst::set_old_password(const char* value) {
  set_has_old_password();
  if (old_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    old_password_ = new ::std::string;
  }
  old_password_->assign(value);
  // @@protoc_insertion_point(field_set_char:ChangePasswordRqst.old_password)
}
inline void ChangePasswordRqst::set_old_password(const char* value, size_t size) {
  set_has_old_password();
  if (old_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    old_password_ = new ::std::string;
  }
  old_password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChangePasswordRqst.old_password)
}
inline ::std::string* ChangePasswordRqst::mutable_old_password() {
  set_has_old_password();
  if (old_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    old_password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ChangePasswordRqst.old_password)
  return old_password_;
}
inline ::std::string* ChangePasswordRqst::release_old_password() {
  clear_has_old_password();
  if (old_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = old_password_;
    old_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChangePasswordRqst::set_allocated_old_password(::std::string* old_password) {
  if (old_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete old_password_;
  }
  if (old_password) {
    set_has_old_password();
    old_password_ = old_password;
  } else {
    clear_has_old_password();
    old_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ChangePasswordRqst.old_password)
}

// required string new_password = 2;
inline bool ChangePasswordRqst::has_new_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangePasswordRqst::set_has_new_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangePasswordRqst::clear_has_new_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangePasswordRqst::clear_new_password() {
  if (new_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_password_->clear();
  }
  clear_has_new_password();
}
inline const ::std::string& ChangePasswordRqst::new_password() const {
  // @@protoc_insertion_point(field_get:ChangePasswordRqst.new_password)
  return *new_password_;
}
inline void ChangePasswordRqst::set_new_password(const ::std::string& value) {
  set_has_new_password();
  if (new_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_password_ = new ::std::string;
  }
  new_password_->assign(value);
  // @@protoc_insertion_point(field_set:ChangePasswordRqst.new_password)
}
inline void ChangePasswordRqst::set_new_password(const char* value) {
  set_has_new_password();
  if (new_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_password_ = new ::std::string;
  }
  new_password_->assign(value);
  // @@protoc_insertion_point(field_set_char:ChangePasswordRqst.new_password)
}
inline void ChangePasswordRqst::set_new_password(const char* value, size_t size) {
  set_has_new_password();
  if (new_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_password_ = new ::std::string;
  }
  new_password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChangePasswordRqst.new_password)
}
inline ::std::string* ChangePasswordRqst::mutable_new_password() {
  set_has_new_password();
  if (new_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ChangePasswordRqst.new_password)
  return new_password_;
}
inline ::std::string* ChangePasswordRqst::release_new_password() {
  clear_has_new_password();
  if (new_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = new_password_;
    new_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChangePasswordRqst::set_allocated_new_password(::std::string* new_password) {
  if (new_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete new_password_;
  }
  if (new_password) {
    set_has_new_password();
    new_password_ = new_password;
  } else {
    clear_has_new_password();
    new_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ChangePasswordRqst.new_password)
}

// -------------------------------------------------------------------

// HeartbeatRqst

// required uint32 expires = 1;
inline bool HeartbeatRqst::has_expires() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatRqst::set_has_expires() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatRqst::clear_has_expires() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatRqst::clear_expires() {
  expires_ = 0u;
  clear_has_expires();
}
inline ::google::protobuf::uint32 HeartbeatRqst::expires() const {
  // @@protoc_insertion_point(field_get:HeartbeatRqst.expires)
  return expires_;
}
inline void HeartbeatRqst::set_expires(::google::protobuf::uint32 value) {
  set_has_expires();
  expires_ = value;
  // @@protoc_insertion_point(field_set:HeartbeatRqst.expires)
}

// required uint64 time = 2;
inline bool HeartbeatRqst::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatRqst::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatRqst::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatRqst::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 HeartbeatRqst::time() const {
  // @@protoc_insertion_point(field_get:HeartbeatRqst.time)
  return time_;
}
inline void HeartbeatRqst::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:HeartbeatRqst.time)
}

// -------------------------------------------------------------------

// HeartbeatRsps

// required uint32 expires = 1;
inline bool HeartbeatRsps::has_expires() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatRsps::set_has_expires() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatRsps::clear_has_expires() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatRsps::clear_expires() {
  expires_ = 0u;
  clear_has_expires();
}
inline ::google::protobuf::uint32 HeartbeatRsps::expires() const {
  // @@protoc_insertion_point(field_get:HeartbeatRsps.expires)
  return expires_;
}
inline void HeartbeatRsps::set_expires(::google::protobuf::uint32 value) {
  set_has_expires();
  expires_ = value;
  // @@protoc_insertion_point(field_set:HeartbeatRsps.expires)
}

// required uint32 capability = 2;
inline bool HeartbeatRsps::has_capability() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatRsps::set_has_capability() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatRsps::clear_has_capability() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatRsps::clear_capability() {
  capability_ = 0u;
  clear_has_capability();
}
inline ::google::protobuf::uint32 HeartbeatRsps::capability() const {
  // @@protoc_insertion_point(field_get:HeartbeatRsps.capability)
  return capability_;
}
inline void HeartbeatRsps::set_capability(::google::protobuf::uint32 value) {
  set_has_capability();
  capability_ = value;
  // @@protoc_insertion_point(field_set:HeartbeatRsps.capability)
}

// required uint32 nodes = 3;
inline bool HeartbeatRsps::has_nodes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartbeatRsps::set_has_nodes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeartbeatRsps::clear_has_nodes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeartbeatRsps::clear_nodes() {
  nodes_ = 0u;
  clear_has_nodes();
}
inline ::google::protobuf::uint32 HeartbeatRsps::nodes() const {
  // @@protoc_insertion_point(field_get:HeartbeatRsps.nodes)
  return nodes_;
}
inline void HeartbeatRsps::set_nodes(::google::protobuf::uint32 value) {
  set_has_nodes();
  nodes_ = value;
  // @@protoc_insertion_point(field_set:HeartbeatRsps.nodes)
}

// required uint32 sessions = 4;
inline bool HeartbeatRsps::has_sessions() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeartbeatRsps::set_has_sessions() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeartbeatRsps::clear_has_sessions() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeartbeatRsps::clear_sessions() {
  sessions_ = 0u;
  clear_has_sessions();
}
inline ::google::protobuf::uint32 HeartbeatRsps::sessions() const {
  // @@protoc_insertion_point(field_get:HeartbeatRsps.sessions)
  return sessions_;
}
inline void HeartbeatRsps::set_sessions(::google::protobuf::uint32 value) {
  set_has_sessions();
  sessions_ = value;
  // @@protoc_insertion_point(field_set:HeartbeatRsps.sessions)
}

// -------------------------------------------------------------------

// RegisterRqst

// required .DeviceType type = 1;
inline bool RegisterRqst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRqst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRqst::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::DeviceType RegisterRqst::type() const {
  // @@protoc_insertion_point(field_get:RegisterRqst.type)
  return static_cast< ::DeviceType >(type_);
}
inline void RegisterRqst::set_type(::DeviceType value) {
  assert(::DeviceType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:RegisterRqst.type)
}

// required string nw_id = 2;
inline bool RegisterRqst::has_nw_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterRqst::set_has_nw_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterRqst::clear_has_nw_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterRqst::clear_nw_id() {
  if (nw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_->clear();
  }
  clear_has_nw_id();
}
inline const ::std::string& RegisterRqst::nw_id() const {
  // @@protoc_insertion_point(field_get:RegisterRqst.nw_id)
  return *nw_id_;
}
inline void RegisterRqst::set_nw_id(const ::std::string& value) {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  nw_id_->assign(value);
  // @@protoc_insertion_point(field_set:RegisterRqst.nw_id)
}
inline void RegisterRqst::set_nw_id(const char* value) {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  nw_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:RegisterRqst.nw_id)
}
inline void RegisterRqst::set_nw_id(const char* value, size_t size) {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  nw_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegisterRqst.nw_id)
}
inline ::std::string* RegisterRqst::mutable_nw_id() {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RegisterRqst.nw_id)
  return nw_id_;
}
inline ::std::string* RegisterRqst::release_nw_id() {
  clear_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nw_id_;
    nw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterRqst::set_allocated_nw_id(::std::string* nw_id) {
  if (nw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nw_id_;
  }
  if (nw_id) {
    set_has_nw_id();
    nw_id_ = nw_id;
  } else {
    clear_has_nw_id();
    nw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterRqst.nw_id)
}

// required string manufactory = 3;
inline bool RegisterRqst::has_manufactory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterRqst::set_has_manufactory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterRqst::clear_has_manufactory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterRqst::clear_manufactory() {
  if (manufactory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufactory_->clear();
  }
  clear_has_manufactory();
}
inline const ::std::string& RegisterRqst::manufactory() const {
  // @@protoc_insertion_point(field_get:RegisterRqst.manufactory)
  return *manufactory_;
}
inline void RegisterRqst::set_manufactory(const ::std::string& value) {
  set_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufactory_ = new ::std::string;
  }
  manufactory_->assign(value);
  // @@protoc_insertion_point(field_set:RegisterRqst.manufactory)
}
inline void RegisterRqst::set_manufactory(const char* value) {
  set_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufactory_ = new ::std::string;
  }
  manufactory_->assign(value);
  // @@protoc_insertion_point(field_set_char:RegisterRqst.manufactory)
}
inline void RegisterRqst::set_manufactory(const char* value, size_t size) {
  set_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufactory_ = new ::std::string;
  }
  manufactory_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegisterRqst.manufactory)
}
inline ::std::string* RegisterRqst::mutable_manufactory() {
  set_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufactory_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RegisterRqst.manufactory)
  return manufactory_;
}
inline ::std::string* RegisterRqst::release_manufactory() {
  clear_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = manufactory_;
    manufactory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterRqst::set_allocated_manufactory(::std::string* manufactory) {
  if (manufactory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manufactory_;
  }
  if (manufactory) {
    set_has_manufactory();
    manufactory_ = manufactory;
  } else {
    clear_has_manufactory();
    manufactory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterRqst.manufactory)
}

// required .DeviceModel model = 4;
inline bool RegisterRqst::has_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterRqst::set_has_model() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterRqst::clear_has_model() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterRqst::clear_model() {
  model_ = 1;
  clear_has_model();
}
inline ::DeviceModel RegisterRqst::model() const {
  // @@protoc_insertion_point(field_get:RegisterRqst.model)
  return static_cast< ::DeviceModel >(model_);
}
inline void RegisterRqst::set_model(::DeviceModel value) {
  assert(::DeviceModel_IsValid(value));
  set_has_model();
  model_ = value;
  // @@protoc_insertion_point(field_set:RegisterRqst.model)
}

// required uint32 nodes = 5;
inline bool RegisterRqst::has_nodes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterRqst::set_has_nodes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterRqst::clear_has_nodes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterRqst::clear_nodes() {
  nodes_ = 0u;
  clear_has_nodes();
}
inline ::google::protobuf::uint32 RegisterRqst::nodes() const {
  // @@protoc_insertion_point(field_get:RegisterRqst.nodes)
  return nodes_;
}
inline void RegisterRqst::set_nodes(::google::protobuf::uint32 value) {
  set_has_nodes();
  nodes_ = value;
  // @@protoc_insertion_point(field_set:RegisterRqst.nodes)
}

// required uint32 session = 6;
inline bool RegisterRqst::has_session() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegisterRqst::set_has_session() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegisterRqst::clear_has_session() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegisterRqst::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 RegisterRqst::session() const {
  // @@protoc_insertion_point(field_get:RegisterRqst.session)
  return session_;
}
inline void RegisterRqst::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
  // @@protoc_insertion_point(field_set:RegisterRqst.session)
}

// -------------------------------------------------------------------

// RegisterRsps

// required uint64 time = 1;
inline bool RegisterRsps::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRsps::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRsps::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRsps::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 RegisterRsps::time() const {
  // @@protoc_insertion_point(field_get:RegisterRsps.time)
  return time_;
}
inline void RegisterRsps::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:RegisterRsps.time)
}

// required uint32 expires = 2;
inline bool RegisterRsps::has_expires() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterRsps::set_has_expires() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterRsps::clear_has_expires() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterRsps::clear_expires() {
  expires_ = 0u;
  clear_has_expires();
}
inline ::google::protobuf::uint32 RegisterRsps::expires() const {
  // @@protoc_insertion_point(field_get:RegisterRsps.expires)
  return expires_;
}
inline void RegisterRsps::set_expires(::google::protobuf::uint32 value) {
  set_has_expires();
  expires_ = value;
  // @@protoc_insertion_point(field_set:RegisterRsps.expires)
}

// -------------------------------------------------------------------

// GetNWInfoRqst

// required bytes nw_id = 1;
inline bool GetNWInfoRqst::has_nw_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNWInfoRqst::set_has_nw_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNWInfoRqst::clear_has_nw_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNWInfoRqst::clear_nw_id() {
  if (nw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_->clear();
  }
  clear_has_nw_id();
}
inline const ::std::string& GetNWInfoRqst::nw_id() const {
  // @@protoc_insertion_point(field_get:GetNWInfoRqst.nw_id)
  return *nw_id_;
}
inline void GetNWInfoRqst::set_nw_id(const ::std::string& value) {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  nw_id_->assign(value);
  // @@protoc_insertion_point(field_set:GetNWInfoRqst.nw_id)
}
inline void GetNWInfoRqst::set_nw_id(const char* value) {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  nw_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNWInfoRqst.nw_id)
}
inline void GetNWInfoRqst::set_nw_id(const void* value, size_t size) {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  nw_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNWInfoRqst.nw_id)
}
inline ::std::string* GetNWInfoRqst::mutable_nw_id() {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNWInfoRqst.nw_id)
  return nw_id_;
}
inline ::std::string* GetNWInfoRqst::release_nw_id() {
  clear_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nw_id_;
    nw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNWInfoRqst::set_allocated_nw_id(::std::string* nw_id) {
  if (nw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nw_id_;
  }
  if (nw_id) {
    set_has_nw_id();
    nw_id_ = nw_id;
  } else {
    clear_has_nw_id();
    nw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNWInfoRqst.nw_id)
}

// -------------------------------------------------------------------

// GetNWInfoRsps

// required string manufactory = 1;
inline bool GetNWInfoRsps::has_manufactory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNWInfoRsps::set_has_manufactory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNWInfoRsps::clear_has_manufactory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNWInfoRsps::clear_manufactory() {
  if (manufactory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufactory_->clear();
  }
  clear_has_manufactory();
}
inline const ::std::string& GetNWInfoRsps::manufactory() const {
  // @@protoc_insertion_point(field_get:GetNWInfoRsps.manufactory)
  return *manufactory_;
}
inline void GetNWInfoRsps::set_manufactory(const ::std::string& value) {
  set_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufactory_ = new ::std::string;
  }
  manufactory_->assign(value);
  // @@protoc_insertion_point(field_set:GetNWInfoRsps.manufactory)
}
inline void GetNWInfoRsps::set_manufactory(const char* value) {
  set_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufactory_ = new ::std::string;
  }
  manufactory_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNWInfoRsps.manufactory)
}
inline void GetNWInfoRsps::set_manufactory(const char* value, size_t size) {
  set_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufactory_ = new ::std::string;
  }
  manufactory_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNWInfoRsps.manufactory)
}
inline ::std::string* GetNWInfoRsps::mutable_manufactory() {
  set_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufactory_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNWInfoRsps.manufactory)
  return manufactory_;
}
inline ::std::string* GetNWInfoRsps::release_manufactory() {
  clear_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = manufactory_;
    manufactory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNWInfoRsps::set_allocated_manufactory(::std::string* manufactory) {
  if (manufactory_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manufactory_;
  }
  if (manufactory) {
    set_has_manufactory();
    manufactory_ = manufactory;
  } else {
    clear_has_manufactory();
    manufactory_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNWInfoRsps.manufactory)
}

// required .DeviceModel model = 2;
inline bool GetNWInfoRsps::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetNWInfoRsps::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetNWInfoRsps::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetNWInfoRsps::clear_model() {
  model_ = 1;
  clear_has_model();
}
inline ::DeviceModel GetNWInfoRsps::model() const {
  // @@protoc_insertion_point(field_get:GetNWInfoRsps.model)
  return static_cast< ::DeviceModel >(model_);
}
inline void GetNWInfoRsps::set_model(::DeviceModel value) {
  assert(::DeviceModel_IsValid(value));
  set_has_model();
  model_ = value;
  // @@protoc_insertion_point(field_set:GetNWInfoRsps.model)
}

// required uint32 node_count = 3;
inline bool GetNWInfoRsps::has_node_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetNWInfoRsps::set_has_node_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetNWInfoRsps::clear_has_node_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetNWInfoRsps::clear_node_count() {
  node_count_ = 0u;
  clear_has_node_count();
}
inline ::google::protobuf::uint32 GetNWInfoRsps::node_count() const {
  // @@protoc_insertion_point(field_get:GetNWInfoRsps.node_count)
  return node_count_;
}
inline void GetNWInfoRsps::set_node_count(::google::protobuf::uint32 value) {
  set_has_node_count();
  node_count_ = value;
  // @@protoc_insertion_point(field_set:GetNWInfoRsps.node_count)
}

// required string _3G = 4;
inline bool GetNWInfoRsps::has__3g() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetNWInfoRsps::set_has__3g() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetNWInfoRsps::clear_has__3g() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetNWInfoRsps::clear__3g() {
  if (_3g_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    _3g_->clear();
  }
  clear_has__3g();
}
inline const ::std::string& GetNWInfoRsps::_3g() const {
  // @@protoc_insertion_point(field_get:GetNWInfoRsps._3G)
  return *_3g_;
}
inline void GetNWInfoRsps::set__3g(const ::std::string& value) {
  set_has__3g();
  if (_3g_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    _3g_ = new ::std::string;
  }
  _3g_->assign(value);
  // @@protoc_insertion_point(field_set:GetNWInfoRsps._3G)
}
inline void GetNWInfoRsps::set__3g(const char* value) {
  set_has__3g();
  if (_3g_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    _3g_ = new ::std::string;
  }
  _3g_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNWInfoRsps._3G)
}
inline void GetNWInfoRsps::set__3g(const char* value, size_t size) {
  set_has__3g();
  if (_3g_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    _3g_ = new ::std::string;
  }
  _3g_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNWInfoRsps._3G)
}
inline ::std::string* GetNWInfoRsps::mutable__3g() {
  set_has__3g();
  if (_3g_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    _3g_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNWInfoRsps._3G)
  return _3g_;
}
inline ::std::string* GetNWInfoRsps::release__3g() {
  clear_has__3g();
  if (_3g_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = _3g_;
    _3g_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNWInfoRsps::set_allocated__3g(::std::string* _3g) {
  if (_3g_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete _3g_;
  }
  if (_3g) {
    set_has__3g();
    _3g_ = _3g;
  } else {
    clear_has__3g();
    _3g_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNWInfoRsps._3G)
}

// required string storage = 5;
inline bool GetNWInfoRsps::has_storage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetNWInfoRsps::set_has_storage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetNWInfoRsps::clear_has_storage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetNWInfoRsps::clear_storage() {
  if (storage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    storage_->clear();
  }
  clear_has_storage();
}
inline const ::std::string& GetNWInfoRsps::storage() const {
  // @@protoc_insertion_point(field_get:GetNWInfoRsps.storage)
  return *storage_;
}
inline void GetNWInfoRsps::set_storage(const ::std::string& value) {
  set_has_storage();
  if (storage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    storage_ = new ::std::string;
  }
  storage_->assign(value);
  // @@protoc_insertion_point(field_set:GetNWInfoRsps.storage)
}
inline void GetNWInfoRsps::set_storage(const char* value) {
  set_has_storage();
  if (storage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    storage_ = new ::std::string;
  }
  storage_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNWInfoRsps.storage)
}
inline void GetNWInfoRsps::set_storage(const char* value, size_t size) {
  set_has_storage();
  if (storage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    storage_ = new ::std::string;
  }
  storage_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNWInfoRsps.storage)
}
inline ::std::string* GetNWInfoRsps::mutable_storage() {
  set_has_storage();
  if (storage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    storage_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNWInfoRsps.storage)
  return storage_;
}
inline ::std::string* GetNWInfoRsps::release_storage() {
  clear_has_storage();
  if (storage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = storage_;
    storage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNWInfoRsps::set_allocated_storage(::std::string* storage) {
  if (storage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete storage_;
  }
  if (storage) {
    set_has_storage();
    storage_ = storage;
  } else {
    clear_has_storage();
    storage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNWInfoRsps.storage)
}

// required uint32 space = 6;
inline bool GetNWInfoRsps::has_space() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetNWInfoRsps::set_has_space() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetNWInfoRsps::clear_has_space() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetNWInfoRsps::clear_space() {
  space_ = 0u;
  clear_has_space();
}
inline ::google::protobuf::uint32 GetNWInfoRsps::space() const {
  // @@protoc_insertion_point(field_get:GetNWInfoRsps.space)
  return space_;
}
inline void GetNWInfoRsps::set_space(::google::protobuf::uint32 value) {
  set_has_space();
  space_ = value;
  // @@protoc_insertion_point(field_set:GetNWInfoRsps.space)
}

// required bytes nw_id = 7;
inline bool GetNWInfoRsps::has_nw_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetNWInfoRsps::set_has_nw_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetNWInfoRsps::clear_has_nw_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetNWInfoRsps::clear_nw_id() {
  if (nw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_->clear();
  }
  clear_has_nw_id();
}
inline const ::std::string& GetNWInfoRsps::nw_id() const {
  // @@protoc_insertion_point(field_get:GetNWInfoRsps.nw_id)
  return *nw_id_;
}
inline void GetNWInfoRsps::set_nw_id(const ::std::string& value) {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  nw_id_->assign(value);
  // @@protoc_insertion_point(field_set:GetNWInfoRsps.nw_id)
}
inline void GetNWInfoRsps::set_nw_id(const char* value) {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  nw_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNWInfoRsps.nw_id)
}
inline void GetNWInfoRsps::set_nw_id(const void* value, size_t size) {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  nw_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNWInfoRsps.nw_id)
}
inline ::std::string* GetNWInfoRsps::mutable_nw_id() {
  set_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nw_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNWInfoRsps.nw_id)
  return nw_id_;
}
inline ::std::string* GetNWInfoRsps::release_nw_id() {
  clear_has_nw_id();
  if (nw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nw_id_;
    nw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNWInfoRsps::set_allocated_nw_id(::std::string* nw_id) {
  if (nw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nw_id_;
  }
  if (nw_id) {
    set_has_nw_id();
    nw_id_ = nw_id;
  } else {
    clear_has_nw_id();
    nw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNWInfoRsps.nw_id)
}

// required string band = 8;
inline bool GetNWInfoRsps::has_band() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetNWInfoRsps::set_has_band() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetNWInfoRsps::clear_has_band() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetNWInfoRsps::clear_band() {
  if (band_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    band_->clear();
  }
  clear_has_band();
}
inline const ::std::string& GetNWInfoRsps::band() const {
  // @@protoc_insertion_point(field_get:GetNWInfoRsps.band)
  return *band_;
}
inline void GetNWInfoRsps::set_band(const ::std::string& value) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    band_ = new ::std::string;
  }
  band_->assign(value);
  // @@protoc_insertion_point(field_set:GetNWInfoRsps.band)
}
inline void GetNWInfoRsps::set_band(const char* value) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    band_ = new ::std::string;
  }
  band_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNWInfoRsps.band)
}
inline void GetNWInfoRsps::set_band(const char* value, size_t size) {
  set_has_band();
  if (band_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    band_ = new ::std::string;
  }
  band_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNWInfoRsps.band)
}
inline ::std::string* GetNWInfoRsps::mutable_band() {
  set_has_band();
  if (band_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    band_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNWInfoRsps.band)
  return band_;
}
inline ::std::string* GetNWInfoRsps::release_band() {
  clear_has_band();
  if (band_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = band_;
    band_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNWInfoRsps::set_allocated_band(::std::string* band) {
  if (band_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete band_;
  }
  if (band) {
    set_has_band();
    band_ = band;
  } else {
    clear_has_band();
    band_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNWInfoRsps.band)
}

// required string firmware = 9;
inline bool GetNWInfoRsps::has_firmware() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetNWInfoRsps::set_has_firmware() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetNWInfoRsps::clear_has_firmware() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetNWInfoRsps::clear_firmware() {
  if (firmware_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firmware_->clear();
  }
  clear_has_firmware();
}
inline const ::std::string& GetNWInfoRsps::firmware() const {
  // @@protoc_insertion_point(field_get:GetNWInfoRsps.firmware)
  return *firmware_;
}
inline void GetNWInfoRsps::set_firmware(const ::std::string& value) {
  set_has_firmware();
  if (firmware_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firmware_ = new ::std::string;
  }
  firmware_->assign(value);
  // @@protoc_insertion_point(field_set:GetNWInfoRsps.firmware)
}
inline void GetNWInfoRsps::set_firmware(const char* value) {
  set_has_firmware();
  if (firmware_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firmware_ = new ::std::string;
  }
  firmware_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNWInfoRsps.firmware)
}
inline void GetNWInfoRsps::set_firmware(const char* value, size_t size) {
  set_has_firmware();
  if (firmware_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firmware_ = new ::std::string;
  }
  firmware_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNWInfoRsps.firmware)
}
inline ::std::string* GetNWInfoRsps::mutable_firmware() {
  set_has_firmware();
  if (firmware_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firmware_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNWInfoRsps.firmware)
  return firmware_;
}
inline ::std::string* GetNWInfoRsps::release_firmware() {
  clear_has_firmware();
  if (firmware_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = firmware_;
    firmware_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNWInfoRsps::set_allocated_firmware(::std::string* firmware) {
  if (firmware_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete firmware_;
  }
  if (firmware) {
    set_has_firmware();
    firmware_ = firmware;
  } else {
    clear_has_firmware();
    firmware_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNWInfoRsps.firmware)
}

// required string position = 10;
inline bool GetNWInfoRsps::has_position() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GetNWInfoRsps::set_has_position() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GetNWInfoRsps::clear_has_position() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GetNWInfoRsps::clear_position() {
  if (position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_->clear();
  }
  clear_has_position();
}
inline const ::std::string& GetNWInfoRsps::position() const {
  // @@protoc_insertion_point(field_get:GetNWInfoRsps.position)
  return *position_;
}
inline void GetNWInfoRsps::set_position(const ::std::string& value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(value);
  // @@protoc_insertion_point(field_set:GetNWInfoRsps.position)
}
inline void GetNWInfoRsps::set_position(const char* value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNWInfoRsps.position)
}
inline void GetNWInfoRsps::set_position(const char* value, size_t size) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNWInfoRsps.position)
}
inline ::std::string* GetNWInfoRsps::mutable_position() {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNWInfoRsps.position)
  return position_;
}
inline ::std::string* GetNWInfoRsps::release_position() {
  clear_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = position_;
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNWInfoRsps::set_allocated_position(::std::string* position) {
  if (position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete position_;
  }
  if (position) {
    set_has_position();
    position_ = position;
  } else {
    clear_has_position();
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNWInfoRsps.position)
}

// required string gps = 11;
inline bool GetNWInfoRsps::has_gps() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GetNWInfoRsps::set_has_gps() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GetNWInfoRsps::clear_has_gps() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GetNWInfoRsps::clear_gps() {
  if (gps_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gps_->clear();
  }
  clear_has_gps();
}
inline const ::std::string& GetNWInfoRsps::gps() const {
  // @@protoc_insertion_point(field_get:GetNWInfoRsps.gps)
  return *gps_;
}
inline void GetNWInfoRsps::set_gps(const ::std::string& value) {
  set_has_gps();
  if (gps_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gps_ = new ::std::string;
  }
  gps_->assign(value);
  // @@protoc_insertion_point(field_set:GetNWInfoRsps.gps)
}
inline void GetNWInfoRsps::set_gps(const char* value) {
  set_has_gps();
  if (gps_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gps_ = new ::std::string;
  }
  gps_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNWInfoRsps.gps)
}
inline void GetNWInfoRsps::set_gps(const char* value, size_t size) {
  set_has_gps();
  if (gps_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gps_ = new ::std::string;
  }
  gps_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNWInfoRsps.gps)
}
inline ::std::string* GetNWInfoRsps::mutable_gps() {
  set_has_gps();
  if (gps_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gps_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNWInfoRsps.gps)
  return gps_;
}
inline ::std::string* GetNWInfoRsps::release_gps() {
  clear_has_gps();
  if (gps_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gps_;
    gps_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNWInfoRsps::set_allocated_gps(::std::string* gps) {
  if (gps_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gps_;
  }
  if (gps) {
    set_has_gps();
    gps_ = gps;
  } else {
    clear_has_gps();
    gps_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNWInfoRsps.gps)
}

// -------------------------------------------------------------------

// SetAutoParamRqst

// required uint32 enable = 1;
inline bool SetAutoParamRqst::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetAutoParamRqst::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetAutoParamRqst::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetAutoParamRqst::clear_enable() {
  enable_ = 0u;
  clear_has_enable();
}
inline ::google::protobuf::uint32 SetAutoParamRqst::enable() const {
  // @@protoc_insertion_point(field_get:SetAutoParamRqst.enable)
  return enable_;
}
inline void SetAutoParamRqst::set_enable(::google::protobuf::uint32 value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:SetAutoParamRqst.enable)
}

// required uint32 ip = 2;
inline bool SetAutoParamRqst::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetAutoParamRqst::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetAutoParamRqst::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetAutoParamRqst::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 SetAutoParamRqst::ip() const {
  // @@protoc_insertion_point(field_get:SetAutoParamRqst.ip)
  return ip_;
}
inline void SetAutoParamRqst::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
  // @@protoc_insertion_point(field_set:SetAutoParamRqst.ip)
}

// required uint32 port = 3;
inline bool SetAutoParamRqst::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetAutoParamRqst::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetAutoParamRqst::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetAutoParamRqst::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 SetAutoParamRqst::port() const {
  // @@protoc_insertion_point(field_get:SetAutoParamRqst.port)
  return port_;
}
inline void SetAutoParamRqst::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:SetAutoParamRqst.port)
}

// required string username = 4;
inline bool SetAutoParamRqst::has_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetAutoParamRqst::set_has_username() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetAutoParamRqst::clear_has_username() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetAutoParamRqst::clear_username() {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& SetAutoParamRqst::username() const {
  // @@protoc_insertion_point(field_get:SetAutoParamRqst.username)
  return *username_;
}
inline void SetAutoParamRqst::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set:SetAutoParamRqst.username)
}
inline void SetAutoParamRqst::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set_char:SetAutoParamRqst.username)
}
inline void SetAutoParamRqst::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetAutoParamRqst.username)
}
inline ::std::string* SetAutoParamRqst::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SetAutoParamRqst.username)
  return username_;
}
inline ::std::string* SetAutoParamRqst::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetAutoParamRqst::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SetAutoParamRqst.username)
}

// required string password = 5;
inline bool SetAutoParamRqst::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetAutoParamRqst::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetAutoParamRqst::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetAutoParamRqst::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& SetAutoParamRqst::password() const {
  // @@protoc_insertion_point(field_get:SetAutoParamRqst.password)
  return *password_;
}
inline void SetAutoParamRqst::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:SetAutoParamRqst.password)
}
inline void SetAutoParamRqst::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:SetAutoParamRqst.password)
}
inline void SetAutoParamRqst::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetAutoParamRqst.password)
}
inline ::std::string* SetAutoParamRqst::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SetAutoParamRqst.password)
  return password_;
}
inline ::std::string* SetAutoParamRqst::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetAutoParamRqst::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SetAutoParamRqst.password)
}

// required uint32 interval = 6;
inline bool SetAutoParamRqst::has_interval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SetAutoParamRqst::set_has_interval() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SetAutoParamRqst::clear_has_interval() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SetAutoParamRqst::clear_interval() {
  interval_ = 0u;
  clear_has_interval();
}
inline ::google::protobuf::uint32 SetAutoParamRqst::interval() const {
  // @@protoc_insertion_point(field_get:SetAutoParamRqst.interval)
  return interval_;
}
inline void SetAutoParamRqst::set_interval(::google::protobuf::uint32 value) {
  set_has_interval();
  interval_ = value;
  // @@protoc_insertion_point(field_set:SetAutoParamRqst.interval)
}

// -------------------------------------------------------------------

// GetAutoParamRsps

// required uint32 enable = 1;
inline bool GetAutoParamRsps::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAutoParamRsps::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAutoParamRsps::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAutoParamRsps::clear_enable() {
  enable_ = 0u;
  clear_has_enable();
}
inline ::google::protobuf::uint32 GetAutoParamRsps::enable() const {
  // @@protoc_insertion_point(field_get:GetAutoParamRsps.enable)
  return enable_;
}
inline void GetAutoParamRsps::set_enable(::google::protobuf::uint32 value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:GetAutoParamRsps.enable)
}

// required string ip = 2;
inline bool GetAutoParamRsps::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAutoParamRsps::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAutoParamRsps::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAutoParamRsps::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& GetAutoParamRsps::ip() const {
  // @@protoc_insertion_point(field_get:GetAutoParamRsps.ip)
  return *ip_;
}
inline void GetAutoParamRsps::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:GetAutoParamRsps.ip)
}
inline void GetAutoParamRsps::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetAutoParamRsps.ip)
}
inline void GetAutoParamRsps::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetAutoParamRsps.ip)
}
inline ::std::string* GetAutoParamRsps::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetAutoParamRsps.ip)
  return ip_;
}
inline ::std::string* GetAutoParamRsps::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetAutoParamRsps::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetAutoParamRsps.ip)
}

// required uint32 port = 3;
inline bool GetAutoParamRsps::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAutoParamRsps::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAutoParamRsps::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAutoParamRsps::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 GetAutoParamRsps::port() const {
  // @@protoc_insertion_point(field_get:GetAutoParamRsps.port)
  return port_;
}
inline void GetAutoParamRsps::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:GetAutoParamRsps.port)
}

// required string username = 4;
inline bool GetAutoParamRsps::has_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetAutoParamRsps::set_has_username() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetAutoParamRsps::clear_has_username() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetAutoParamRsps::clear_username() {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& GetAutoParamRsps::username() const {
  // @@protoc_insertion_point(field_get:GetAutoParamRsps.username)
  return *username_;
}
inline void GetAutoParamRsps::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set:GetAutoParamRsps.username)
}
inline void GetAutoParamRsps::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetAutoParamRsps.username)
}
inline void GetAutoParamRsps::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetAutoParamRsps.username)
}
inline ::std::string* GetAutoParamRsps::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetAutoParamRsps.username)
  return username_;
}
inline ::std::string* GetAutoParamRsps::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetAutoParamRsps::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetAutoParamRsps.username)
}

// required string password = 5;
inline bool GetAutoParamRsps::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetAutoParamRsps::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetAutoParamRsps::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetAutoParamRsps::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& GetAutoParamRsps::password() const {
  // @@protoc_insertion_point(field_get:GetAutoParamRsps.password)
  return *password_;
}
inline void GetAutoParamRsps::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:GetAutoParamRsps.password)
}
inline void GetAutoParamRsps::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetAutoParamRsps.password)
}
inline void GetAutoParamRsps::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetAutoParamRsps.password)
}
inline ::std::string* GetAutoParamRsps::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetAutoParamRsps.password)
  return password_;
}
inline ::std::string* GetAutoParamRsps::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetAutoParamRsps::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetAutoParamRsps.password)
}

// required uint32 interval = 6;
inline bool GetAutoParamRsps::has_interval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetAutoParamRsps::set_has_interval() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetAutoParamRsps::clear_has_interval() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetAutoParamRsps::clear_interval() {
  interval_ = 0u;
  clear_has_interval();
}
inline ::google::protobuf::uint32 GetAutoParamRsps::interval() const {
  // @@protoc_insertion_point(field_get:GetAutoParamRsps.interval)
  return interval_;
}
inline void GetAutoParamRsps::set_interval(::google::protobuf::uint32 value) {
  set_has_interval();
  interval_ = value;
  // @@protoc_insertion_point(field_set:GetAutoParamRsps.interval)
}

// -------------------------------------------------------------------

// SetConfigRqst

// required .ConfigName name = 1;
inline bool SetConfigRqst::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetConfigRqst::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetConfigRqst::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetConfigRqst::clear_name() {
  name_ = 1;
  clear_has_name();
}
inline ::ConfigName SetConfigRqst::name() const {
  // @@protoc_insertion_point(field_get:SetConfigRqst.name)
  return static_cast< ::ConfigName >(name_);
}
inline void SetConfigRqst::set_name(::ConfigName value) {
  assert(::ConfigName_IsValid(value));
  set_has_name();
  name_ = value;
  // @@protoc_insertion_point(field_set:SetConfigRqst.name)
}

// required string config_file = 2;
inline bool SetConfigRqst::has_config_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetConfigRqst::set_has_config_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetConfigRqst::clear_has_config_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetConfigRqst::clear_config_file() {
  if (config_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_->clear();
  }
  clear_has_config_file();
}
inline const ::std::string& SetConfigRqst::config_file() const {
  // @@protoc_insertion_point(field_get:SetConfigRqst.config_file)
  return *config_file_;
}
inline void SetConfigRqst::set_config_file(const ::std::string& value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
  // @@protoc_insertion_point(field_set:SetConfigRqst.config_file)
}
inline void SetConfigRqst::set_config_file(const char* value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
  // @@protoc_insertion_point(field_set_char:SetConfigRqst.config_file)
}
inline void SetConfigRqst::set_config_file(const char* value, size_t size) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetConfigRqst.config_file)
}
inline ::std::string* SetConfigRqst::mutable_config_file() {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SetConfigRqst.config_file)
  return config_file_;
}
inline ::std::string* SetConfigRqst::release_config_file() {
  clear_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = config_file_;
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetConfigRqst::set_allocated_config_file(::std::string* config_file) {
  if (config_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete config_file_;
  }
  if (config_file) {
    set_has_config_file();
    config_file_ = config_file;
  } else {
    clear_has_config_file();
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SetConfigRqst.config_file)
}

// -------------------------------------------------------------------

// GetConfigRqst

// required .ConfigName name = 1;
inline bool GetConfigRqst::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetConfigRqst::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetConfigRqst::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetConfigRqst::clear_name() {
  name_ = 1;
  clear_has_name();
}
inline ::ConfigName GetConfigRqst::name() const {
  // @@protoc_insertion_point(field_get:GetConfigRqst.name)
  return static_cast< ::ConfigName >(name_);
}
inline void GetConfigRqst::set_name(::ConfigName value) {
  assert(::ConfigName_IsValid(value));
  set_has_name();
  name_ = value;
  // @@protoc_insertion_point(field_set:GetConfigRqst.name)
}

// -------------------------------------------------------------------

// GetConfigRsps

// required string config_file = 1;
inline bool GetConfigRsps::has_config_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetConfigRsps::set_has_config_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetConfigRsps::clear_has_config_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetConfigRsps::clear_config_file() {
  if (config_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_->clear();
  }
  clear_has_config_file();
}
inline const ::std::string& GetConfigRsps::config_file() const {
  // @@protoc_insertion_point(field_get:GetConfigRsps.config_file)
  return *config_file_;
}
inline void GetConfigRsps::set_config_file(const ::std::string& value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
  // @@protoc_insertion_point(field_set:GetConfigRsps.config_file)
}
inline void GetConfigRsps::set_config_file(const char* value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetConfigRsps.config_file)
}
inline void GetConfigRsps::set_config_file(const char* value, size_t size) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetConfigRsps.config_file)
}
inline ::std::string* GetConfigRsps::mutable_config_file() {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetConfigRsps.config_file)
  return config_file_;
}
inline ::std::string* GetConfigRsps::release_config_file() {
  clear_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = config_file_;
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetConfigRsps::set_allocated_config_file(::std::string* config_file) {
  if (config_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete config_file_;
  }
  if (config_file) {
    set_has_config_file();
    config_file_ = config_file;
  } else {
    clear_has_config_file();
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetConfigRsps.config_file)
}

// -------------------------------------------------------------------

// QueryLogRqst

// required .LogType type = 1;
inline bool QueryLogRqst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryLogRqst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryLogRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryLogRqst::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::LogType QueryLogRqst::type() const {
  // @@protoc_insertion_point(field_get:QueryLogRqst.type)
  return static_cast< ::LogType >(type_);
}
inline void QueryLogRqst::set_type(::LogType value) {
  assert(::LogType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:QueryLogRqst.type)
}

// required uint64 start_time = 2;
inline bool QueryLogRqst::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryLogRqst::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryLogRqst::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryLogRqst::clear_start_time() {
  start_time_ = GOOGLE_ULONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::uint64 QueryLogRqst::start_time() const {
  // @@protoc_insertion_point(field_get:QueryLogRqst.start_time)
  return start_time_;
}
inline void QueryLogRqst::set_start_time(::google::protobuf::uint64 value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:QueryLogRqst.start_time)
}

// required uint64 end_time = 3;
inline bool QueryLogRqst::has_end_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryLogRqst::set_has_end_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryLogRqst::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryLogRqst::clear_end_time() {
  end_time_ = GOOGLE_ULONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::uint64 QueryLogRqst::end_time() const {
  // @@protoc_insertion_point(field_get:QueryLogRqst.end_time)
  return end_time_;
}
inline void QueryLogRqst::set_end_time(::google::protobuf::uint64 value) {
  set_has_end_time();
  end_time_ = value;
  // @@protoc_insertion_point(field_set:QueryLogRqst.end_time)
}

// required uint32 start_line = 4;
inline bool QueryLogRqst::has_start_line() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryLogRqst::set_has_start_line() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryLogRqst::clear_has_start_line() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryLogRqst::clear_start_line() {
  start_line_ = 0u;
  clear_has_start_line();
}
inline ::google::protobuf::uint32 QueryLogRqst::start_line() const {
  // @@protoc_insertion_point(field_get:QueryLogRqst.start_line)
  return start_line_;
}
inline void QueryLogRqst::set_start_line(::google::protobuf::uint32 value) {
  set_has_start_line();
  start_line_ = value;
  // @@protoc_insertion_point(field_set:QueryLogRqst.start_line)
}

// required uint32 count = 5;
inline bool QueryLogRqst::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QueryLogRqst::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QueryLogRqst::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QueryLogRqst::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 QueryLogRqst::count() const {
  // @@protoc_insertion_point(field_get:QueryLogRqst.count)
  return count_;
}
inline void QueryLogRqst::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:QueryLogRqst.count)
}

// -------------------------------------------------------------------

// NWLog

// required uint64 time = 1;
inline bool NWLog::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NWLog::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NWLog::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NWLog::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 NWLog::time() const {
  // @@protoc_insertion_point(field_get:NWLog.time)
  return time_;
}
inline void NWLog::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:NWLog.time)
}

// required .LogType type = 2;
inline bool NWLog::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NWLog::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NWLog::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NWLog::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::LogType NWLog::type() const {
  // @@protoc_insertion_point(field_get:NWLog.type)
  return static_cast< ::LogType >(type_);
}
inline void NWLog::set_type(::LogType value) {
  assert(::LogType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:NWLog.type)
}

// required string message = 3;
inline bool NWLog::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NWLog::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NWLog::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NWLog::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& NWLog::message() const {
  // @@protoc_insertion_point(field_get:NWLog.message)
  return *message_;
}
inline void NWLog::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:NWLog.message)
}
inline void NWLog::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:NWLog.message)
}
inline void NWLog::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NWLog.message)
}
inline ::std::string* NWLog::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NWLog.message)
  return message_;
}
inline ::std::string* NWLog::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NWLog::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NWLog.message)
}

// -------------------------------------------------------------------

// QueryLogRsps

// required uint32 total_count = 1;
inline bool QueryLogRsps::has_total_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryLogRsps::set_has_total_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryLogRsps::clear_has_total_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryLogRsps::clear_total_count() {
  total_count_ = 0u;
  clear_has_total_count();
}
inline ::google::protobuf::uint32 QueryLogRsps::total_count() const {
  // @@protoc_insertion_point(field_get:QueryLogRsps.total_count)
  return total_count_;
}
inline void QueryLogRsps::set_total_count(::google::protobuf::uint32 value) {
  set_has_total_count();
  total_count_ = value;
  // @@protoc_insertion_point(field_set:QueryLogRsps.total_count)
}

// repeated .NWLog log = 2;
inline int QueryLogRsps::log_size() const {
  return log_.size();
}
inline void QueryLogRsps::clear_log() {
  log_.Clear();
}
inline const ::NWLog& QueryLogRsps::log(int index) const {
  // @@protoc_insertion_point(field_get:QueryLogRsps.log)
  return log_.Get(index);
}
inline ::NWLog* QueryLogRsps::mutable_log(int index) {
  // @@protoc_insertion_point(field_mutable:QueryLogRsps.log)
  return log_.Mutable(index);
}
inline ::NWLog* QueryLogRsps::add_log() {
  // @@protoc_insertion_point(field_add:QueryLogRsps.log)
  return log_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NWLog >&
QueryLogRsps::log() const {
  // @@protoc_insertion_point(field_list:QueryLogRsps.log)
  return log_;
}
inline ::google::protobuf::RepeatedPtrField< ::NWLog >*
QueryLogRsps::mutable_log() {
  // @@protoc_insertion_point(field_mutable_list:QueryLogRsps.log)
  return &log_;
}

// -------------------------------------------------------------------

// TimeSynchRqst

// required uint64 time = 1;
inline bool TimeSynchRqst::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeSynchRqst::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeSynchRqst::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeSynchRqst::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 TimeSynchRqst::time() const {
  // @@protoc_insertion_point(field_get:TimeSynchRqst.time)
  return time_;
}
inline void TimeSynchRqst::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:TimeSynchRqst.time)
}

// required string ip = 2;
inline bool TimeSynchRqst::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeSynchRqst::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeSynchRqst::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeSynchRqst::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& TimeSynchRqst::ip() const {
  // @@protoc_insertion_point(field_get:TimeSynchRqst.ip)
  return *ip_;
}
inline void TimeSynchRqst::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:TimeSynchRqst.ip)
}
inline void TimeSynchRqst::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:TimeSynchRqst.ip)
}
inline void TimeSynchRqst::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TimeSynchRqst.ip)
}
inline ::std::string* TimeSynchRqst::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TimeSynchRqst.ip)
  return ip_;
}
inline ::std::string* TimeSynchRqst::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TimeSynchRqst::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TimeSynchRqst.ip)
}

// required uint32 port = 3;
inline bool TimeSynchRqst::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeSynchRqst::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeSynchRqst::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeSynchRqst::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TimeSynchRqst::port() const {
  // @@protoc_insertion_point(field_get:TimeSynchRqst.port)
  return port_;
}
inline void TimeSynchRqst::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:TimeSynchRqst.port)
}

// required uint32 revision = 4;
inline bool TimeSynchRqst::has_revision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimeSynchRqst::set_has_revision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimeSynchRqst::clear_has_revision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimeSynchRqst::clear_revision() {
  revision_ = 0u;
  clear_has_revision();
}
inline ::google::protobuf::uint32 TimeSynchRqst::revision() const {
  // @@protoc_insertion_point(field_get:TimeSynchRqst.revision)
  return revision_;
}
inline void TimeSynchRqst::set_revision(::google::protobuf::uint32 value) {
  set_has_revision();
  revision_ = value;
  // @@protoc_insertion_point(field_set:TimeSynchRqst.revision)
}

// -------------------------------------------------------------------

// RebootRqst

// required string reason = 1;
inline bool RebootRqst::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RebootRqst::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RebootRqst::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RebootRqst::clear_reason() {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& RebootRqst::reason() const {
  // @@protoc_insertion_point(field_get:RebootRqst.reason)
  return *reason_;
}
inline void RebootRqst::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set:RebootRqst.reason)
}
inline void RebootRqst::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set_char:RebootRqst.reason)
}
inline void RebootRqst::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RebootRqst.reason)
}
inline ::std::string* RebootRqst::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RebootRqst.reason)
  return reason_;
}
inline ::std::string* RebootRqst::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RebootRqst::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RebootRqst.reason)
}

// required uint32 delay = 2;
inline bool RebootRqst::has_delay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RebootRqst::set_has_delay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RebootRqst::clear_has_delay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RebootRqst::clear_delay() {
  delay_ = 0u;
  clear_has_delay();
}
inline ::google::protobuf::uint32 RebootRqst::delay() const {
  // @@protoc_insertion_point(field_get:RebootRqst.delay)
  return delay_;
}
inline void RebootRqst::set_delay(::google::protobuf::uint32 value) {
  set_has_delay();
  delay_ = value;
  // @@protoc_insertion_point(field_set:RebootRqst.delay)
}

// -------------------------------------------------------------------

// GetNodeListRqst

// required .NodeType type = 1;
inline bool GetNodeListRqst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNodeListRqst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNodeListRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNodeListRqst::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::NodeType GetNodeListRqst::type() const {
  // @@protoc_insertion_point(field_get:GetNodeListRqst.type)
  return static_cast< ::NodeType >(type_);
}
inline void GetNodeListRqst::set_type(::NodeType value) {
  assert(::NodeType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:GetNodeListRqst.type)
}

// required uint32 start_line = 2;
inline bool GetNodeListRqst::has_start_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetNodeListRqst::set_has_start_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetNodeListRqst::clear_has_start_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetNodeListRqst::clear_start_line() {
  start_line_ = 0u;
  clear_has_start_line();
}
inline ::google::protobuf::uint32 GetNodeListRqst::start_line() const {
  // @@protoc_insertion_point(field_get:GetNodeListRqst.start_line)
  return start_line_;
}
inline void GetNodeListRqst::set_start_line(::google::protobuf::uint32 value) {
  set_has_start_line();
  start_line_ = value;
  // @@protoc_insertion_point(field_set:GetNodeListRqst.start_line)
}

// required uint32 count = 3;
inline bool GetNodeListRqst::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetNodeListRqst::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetNodeListRqst::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetNodeListRqst::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 GetNodeListRqst::count() const {
  // @@protoc_insertion_point(field_get:GetNodeListRqst.count)
  return count_;
}
inline void GetNodeListRqst::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:GetNodeListRqst.count)
}

// -------------------------------------------------------------------

// GetNodeListRsps

// required uint32 total_count = 1;
inline bool GetNodeListRsps::has_total_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNodeListRsps::set_has_total_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNodeListRsps::clear_has_total_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNodeListRsps::clear_total_count() {
  total_count_ = 0u;
  clear_has_total_count();
}
inline ::google::protobuf::uint32 GetNodeListRsps::total_count() const {
  // @@protoc_insertion_point(field_get:GetNodeListRsps.total_count)
  return total_count_;
}
inline void GetNodeListRsps::set_total_count(::google::protobuf::uint32 value) {
  set_has_total_count();
  total_count_ = value;
  // @@protoc_insertion_point(field_set:GetNodeListRsps.total_count)
}

// repeated .NodeEntry node_entry = 2;
inline int GetNodeListRsps::node_entry_size() const {
  return node_entry_.size();
}
inline void GetNodeListRsps::clear_node_entry() {
  node_entry_.Clear();
}
inline const ::NodeEntry& GetNodeListRsps::node_entry(int index) const {
  // @@protoc_insertion_point(field_get:GetNodeListRsps.node_entry)
  return node_entry_.Get(index);
}
inline ::NodeEntry* GetNodeListRsps::mutable_node_entry(int index) {
  // @@protoc_insertion_point(field_mutable:GetNodeListRsps.node_entry)
  return node_entry_.Mutable(index);
}
inline ::NodeEntry* GetNodeListRsps::add_node_entry() {
  // @@protoc_insertion_point(field_add:GetNodeListRsps.node_entry)
  return node_entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NodeEntry >&
GetNodeListRsps::node_entry() const {
  // @@protoc_insertion_point(field_list:GetNodeListRsps.node_entry)
  return node_entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::NodeEntry >*
GetNodeListRsps::mutable_node_entry() {
  // @@protoc_insertion_point(field_mutable_list:GetNodeListRsps.node_entry)
  return &node_entry_;
}

// -------------------------------------------------------------------

// NodeEntry

// required bytes id = 1;
inline bool NodeEntry::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeEntry::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeEntry::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeEntry::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& NodeEntry::id() const {
  // @@protoc_insertion_point(field_get:NodeEntry.id)
  return *id_;
}
inline void NodeEntry::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:NodeEntry.id)
}
inline void NodeEntry::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:NodeEntry.id)
}
inline void NodeEntry::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NodeEntry.id)
}
inline ::std::string* NodeEntry::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NodeEntry.id)
  return id_;
}
inline ::std::string* NodeEntry::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NodeEntry::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NodeEntry.id)
}

// required uint32 status = 2;
inline bool NodeEntry::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeEntry::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeEntry::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeEntry::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 NodeEntry::status() const {
  // @@protoc_insertion_point(field_get:NodeEntry.status)
  return status_;
}
inline void NodeEntry::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:NodeEntry.status)
}

// required uint32 sensor1 = 3;
inline bool NodeEntry::has_sensor1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeEntry::set_has_sensor1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeEntry::clear_has_sensor1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeEntry::clear_sensor1() {
  sensor1_ = 0u;
  clear_has_sensor1();
}
inline ::google::protobuf::uint32 NodeEntry::sensor1() const {
  // @@protoc_insertion_point(field_get:NodeEntry.sensor1)
  return sensor1_;
}
inline void NodeEntry::set_sensor1(::google::protobuf::uint32 value) {
  set_has_sensor1();
  sensor1_ = value;
  // @@protoc_insertion_point(field_set:NodeEntry.sensor1)
}

// required uint32 sensor2 = 4;
inline bool NodeEntry::has_sensor2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeEntry::set_has_sensor2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeEntry::clear_has_sensor2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeEntry::clear_sensor2() {
  sensor2_ = 0u;
  clear_has_sensor2();
}
inline ::google::protobuf::uint32 NodeEntry::sensor2() const {
  // @@protoc_insertion_point(field_get:NodeEntry.sensor2)
  return sensor2_;
}
inline void NodeEntry::set_sensor2(::google::protobuf::uint32 value) {
  set_has_sensor2();
  sensor2_ = value;
  // @@protoc_insertion_point(field_set:NodeEntry.sensor2)
}

// required uint32 sensor3 = 5;
inline bool NodeEntry::has_sensor3() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeEntry::set_has_sensor3() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeEntry::clear_has_sensor3() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeEntry::clear_sensor3() {
  sensor3_ = 0u;
  clear_has_sensor3();
}
inline ::google::protobuf::uint32 NodeEntry::sensor3() const {
  // @@protoc_insertion_point(field_get:NodeEntry.sensor3)
  return sensor3_;
}
inline void NodeEntry::set_sensor3(::google::protobuf::uint32 value) {
  set_has_sensor3();
  sensor3_ = value;
  // @@protoc_insertion_point(field_set:NodeEntry.sensor3)
}

// required uint32 sensor4 = 6;
inline bool NodeEntry::has_sensor4() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeEntry::set_has_sensor4() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeEntry::clear_has_sensor4() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeEntry::clear_sensor4() {
  sensor4_ = 0u;
  clear_has_sensor4();
}
inline ::google::protobuf::uint32 NodeEntry::sensor4() const {
  // @@protoc_insertion_point(field_get:NodeEntry.sensor4)
  return sensor4_;
}
inline void NodeEntry::set_sensor4(::google::protobuf::uint32 value) {
  set_has_sensor4();
  sensor4_ = value;
  // @@protoc_insertion_point(field_set:NodeEntry.sensor4)
}

// required uint32 sensor5 = 7;
inline bool NodeEntry::has_sensor5() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NodeEntry::set_has_sensor5() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NodeEntry::clear_has_sensor5() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NodeEntry::clear_sensor5() {
  sensor5_ = 0u;
  clear_has_sensor5();
}
inline ::google::protobuf::uint32 NodeEntry::sensor5() const {
  // @@protoc_insertion_point(field_get:NodeEntry.sensor5)
  return sensor5_;
}
inline void NodeEntry::set_sensor5(::google::protobuf::uint32 value) {
  set_has_sensor5();
  sensor5_ = value;
  // @@protoc_insertion_point(field_set:NodeEntry.sensor5)
}

// required uint32 sensor6 = 8;
inline bool NodeEntry::has_sensor6() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NodeEntry::set_has_sensor6() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NodeEntry::clear_has_sensor6() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NodeEntry::clear_sensor6() {
  sensor6_ = 0u;
  clear_has_sensor6();
}
inline ::google::protobuf::uint32 NodeEntry::sensor6() const {
  // @@protoc_insertion_point(field_get:NodeEntry.sensor6)
  return sensor6_;
}
inline void NodeEntry::set_sensor6(::google::protobuf::uint32 value) {
  set_has_sensor6();
  sensor6_ = value;
  // @@protoc_insertion_point(field_set:NodeEntry.sensor6)
}

// -------------------------------------------------------------------

// GetNodeStatusRqst

// required bytes node_id = 1;
inline bool GetNodeStatusRqst::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNodeStatusRqst::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNodeStatusRqst::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNodeStatusRqst::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& GetNodeStatusRqst::node_id() const {
  // @@protoc_insertion_point(field_get:GetNodeStatusRqst.node_id)
  return *node_id_;
}
inline void GetNodeStatusRqst::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:GetNodeStatusRqst.node_id)
}
inline void GetNodeStatusRqst::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNodeStatusRqst.node_id)
}
inline void GetNodeStatusRqst::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNodeStatusRqst.node_id)
}
inline ::std::string* GetNodeStatusRqst::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNodeStatusRqst.node_id)
  return node_id_;
}
inline ::std::string* GetNodeStatusRqst::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNodeStatusRqst::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNodeStatusRqst.node_id)
}

// -------------------------------------------------------------------

// GetNodeStatusRsps

// required .NodeEntry node = 1;
inline bool GetNodeStatusRsps::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNodeStatusRsps::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNodeStatusRsps::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNodeStatusRsps::clear_node() {
  if (node_ != NULL) node_->::NodeEntry::Clear();
  clear_has_node();
}
inline const ::NodeEntry& GetNodeStatusRsps::node() const {
  // @@protoc_insertion_point(field_get:GetNodeStatusRsps.node)
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::NodeEntry* GetNodeStatusRsps::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::NodeEntry;
  // @@protoc_insertion_point(field_mutable:GetNodeStatusRsps.node)
  return node_;
}
inline ::NodeEntry* GetNodeStatusRsps::release_node() {
  clear_has_node();
  ::NodeEntry* temp = node_;
  node_ = NULL;
  return temp;
}
inline void GetNodeStatusRsps::set_allocated_node(::NodeEntry* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:GetNodeStatusRsps.node)
}

// -------------------------------------------------------------------

// GetTopologyRsps

// repeated .Node node = 1;
inline int GetTopologyRsps::node_size() const {
  return node_.size();
}
inline void GetTopologyRsps::clear_node() {
  node_.Clear();
}
inline const ::Node& GetTopologyRsps::node(int index) const {
  // @@protoc_insertion_point(field_get:GetTopologyRsps.node)
  return node_.Get(index);
}
inline ::Node* GetTopologyRsps::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:GetTopologyRsps.node)
  return node_.Mutable(index);
}
inline ::Node* GetTopologyRsps::add_node() {
  // @@protoc_insertion_point(field_add:GetTopologyRsps.node)
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Node >&
GetTopologyRsps::node() const {
  // @@protoc_insertion_point(field_list:GetTopologyRsps.node)
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::Node >*
GetTopologyRsps::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:GetTopologyRsps.node)
  return &node_;
}

// -------------------------------------------------------------------

// Node

// required bytes l_id = 1;
inline bool Node::has_l_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_l_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_l_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_l_id() {
  if (l_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_id_->clear();
  }
  clear_has_l_id();
}
inline const ::std::string& Node::l_id() const {
  // @@protoc_insertion_point(field_get:Node.l_id)
  return *l_id_;
}
inline void Node::set_l_id(const ::std::string& value) {
  set_has_l_id();
  if (l_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_id_ = new ::std::string;
  }
  l_id_->assign(value);
  // @@protoc_insertion_point(field_set:Node.l_id)
}
inline void Node::set_l_id(const char* value) {
  set_has_l_id();
  if (l_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_id_ = new ::std::string;
  }
  l_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Node.l_id)
}
inline void Node::set_l_id(const void* value, size_t size) {
  set_has_l_id();
  if (l_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_id_ = new ::std::string;
  }
  l_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Node.l_id)
}
inline ::std::string* Node::mutable_l_id() {
  set_has_l_id();
  if (l_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Node.l_id)
  return l_id_;
}
inline ::std::string* Node::release_l_id() {
  clear_has_l_id();
  if (l_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = l_id_;
    l_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Node::set_allocated_l_id(::std::string* l_id) {
  if (l_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete l_id_;
  }
  if (l_id) {
    set_has_l_id();
    l_id_ = l_id;
  } else {
    clear_has_l_id();
    l_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Node.l_id)
}

// required string s_id = 2;
inline bool Node::has_s_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_s_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_s_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_s_id() {
  if (s_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_id_->clear();
  }
  clear_has_s_id();
}
inline const ::std::string& Node::s_id() const {
  // @@protoc_insertion_point(field_get:Node.s_id)
  return *s_id_;
}
inline void Node::set_s_id(const ::std::string& value) {
  set_has_s_id();
  if (s_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_id_ = new ::std::string;
  }
  s_id_->assign(value);
  // @@protoc_insertion_point(field_set:Node.s_id)
}
inline void Node::set_s_id(const char* value) {
  set_has_s_id();
  if (s_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_id_ = new ::std::string;
  }
  s_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Node.s_id)
}
inline void Node::set_s_id(const char* value, size_t size) {
  set_has_s_id();
  if (s_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_id_ = new ::std::string;
  }
  s_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Node.s_id)
}
inline ::std::string* Node::mutable_s_id() {
  set_has_s_id();
  if (s_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Node.s_id)
  return s_id_;
}
inline ::std::string* Node::release_s_id() {
  clear_has_s_id();
  if (s_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_id_;
    s_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Node::set_allocated_s_id(::std::string* s_id) {
  if (s_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_id_;
  }
  if (s_id) {
    set_has_s_id();
    s_id_ = s_id;
  } else {
    clear_has_s_id();
    s_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Node.s_id)
}

// required uint32 level = 3;
inline bool Node::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 Node::level() const {
  // @@protoc_insertion_point(field_get:Node.level)
  return level_;
}
inline void Node::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:Node.level)
}

// required uint64 time = 4;
inline bool Node::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Node::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Node::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Node::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 Node::time() const {
  // @@protoc_insertion_point(field_get:Node.time)
  return time_;
}
inline void Node::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Node.time)
}

// required .ParentNode parent = 5;
inline bool Node::has_parent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Node::set_has_parent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Node::clear_has_parent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Node::clear_parent() {
  if (parent_ != NULL) parent_->::ParentNode::Clear();
  clear_has_parent();
}
inline const ::ParentNode& Node::parent() const {
  // @@protoc_insertion_point(field_get:Node.parent)
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::ParentNode* Node::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) parent_ = new ::ParentNode;
  // @@protoc_insertion_point(field_mutable:Node.parent)
  return parent_;
}
inline ::ParentNode* Node::release_parent() {
  clear_has_parent();
  ::ParentNode* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline void Node::set_allocated_parent(::ParentNode* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
  // @@protoc_insertion_point(field_set_allocated:Node.parent)
}

// -------------------------------------------------------------------

// ParentNode

// required bytes l_id = 1;
inline bool ParentNode::has_l_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParentNode::set_has_l_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParentNode::clear_has_l_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParentNode::clear_l_id() {
  if (l_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_id_->clear();
  }
  clear_has_l_id();
}
inline const ::std::string& ParentNode::l_id() const {
  // @@protoc_insertion_point(field_get:ParentNode.l_id)
  return *l_id_;
}
inline void ParentNode::set_l_id(const ::std::string& value) {
  set_has_l_id();
  if (l_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_id_ = new ::std::string;
  }
  l_id_->assign(value);
  // @@protoc_insertion_point(field_set:ParentNode.l_id)
}
inline void ParentNode::set_l_id(const char* value) {
  set_has_l_id();
  if (l_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_id_ = new ::std::string;
  }
  l_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:ParentNode.l_id)
}
inline void ParentNode::set_l_id(const void* value, size_t size) {
  set_has_l_id();
  if (l_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_id_ = new ::std::string;
  }
  l_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ParentNode.l_id)
}
inline ::std::string* ParentNode::mutable_l_id() {
  set_has_l_id();
  if (l_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ParentNode.l_id)
  return l_id_;
}
inline ::std::string* ParentNode::release_l_id() {
  clear_has_l_id();
  if (l_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = l_id_;
    l_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ParentNode::set_allocated_l_id(::std::string* l_id) {
  if (l_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete l_id_;
  }
  if (l_id) {
    set_has_l_id();
    l_id_ = l_id;
  } else {
    clear_has_l_id();
    l_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ParentNode.l_id)
}

// required string s_id = 2;
inline bool ParentNode::has_s_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParentNode::set_has_s_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParentNode::clear_has_s_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParentNode::clear_s_id() {
  if (s_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_id_->clear();
  }
  clear_has_s_id();
}
inline const ::std::string& ParentNode::s_id() const {
  // @@protoc_insertion_point(field_get:ParentNode.s_id)
  return *s_id_;
}
inline void ParentNode::set_s_id(const ::std::string& value) {
  set_has_s_id();
  if (s_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_id_ = new ::std::string;
  }
  s_id_->assign(value);
  // @@protoc_insertion_point(field_set:ParentNode.s_id)
}
inline void ParentNode::set_s_id(const char* value) {
  set_has_s_id();
  if (s_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_id_ = new ::std::string;
  }
  s_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:ParentNode.s_id)
}
inline void ParentNode::set_s_id(const char* value, size_t size) {
  set_has_s_id();
  if (s_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_id_ = new ::std::string;
  }
  s_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ParentNode.s_id)
}
inline ::std::string* ParentNode::mutable_s_id() {
  set_has_s_id();
  if (s_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ParentNode.s_id)
  return s_id_;
}
inline ::std::string* ParentNode::release_s_id() {
  clear_has_s_id();
  if (s_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_id_;
    s_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ParentNode::set_allocated_s_id(::std::string* s_id) {
  if (s_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_id_;
  }
  if (s_id) {
    set_has_s_id();
    s_id_ = s_id;
  } else {
    clear_has_s_id();
    s_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ParentNode.s_id)
}

// required uint32 level = 3;
inline bool ParentNode::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParentNode::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParentNode::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParentNode::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 ParentNode::level() const {
  // @@protoc_insertion_point(field_get:ParentNode.level)
  return level_;
}
inline void ParentNode::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:ParentNode.level)
}

// required uint32 status = 4;
inline bool ParentNode::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParentNode::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParentNode::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParentNode::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 ParentNode::status() const {
  // @@protoc_insertion_point(field_get:ParentNode.status)
  return status_;
}
inline void ParentNode::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:ParentNode.status)
}

// required uint32 priority = 5;
inline bool ParentNode::has_priority() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ParentNode::set_has_priority() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ParentNode::clear_has_priority() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ParentNode::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 ParentNode::priority() const {
  // @@protoc_insertion_point(field_get:ParentNode.priority)
  return priority_;
}
inline void ParentNode::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:ParentNode.priority)
}

// -------------------------------------------------------------------

// SubscribeNotificationNtf

// required .SubscribeNotificationNtf.MessageType message = 1;
inline bool SubscribeNotificationNtf::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeNotificationNtf::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeNotificationNtf::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeNotificationNtf::clear_message() {
  message_ = 1;
  clear_has_message();
}
inline ::SubscribeNotificationNtf_MessageType SubscribeNotificationNtf::message() const {
  // @@protoc_insertion_point(field_get:SubscribeNotificationNtf.message)
  return static_cast< ::SubscribeNotificationNtf_MessageType >(message_);
}
inline void SubscribeNotificationNtf::set_message(::SubscribeNotificationNtf_MessageType value) {
  assert(::SubscribeNotificationNtf_MessageType_IsValid(value));
  set_has_message();
  message_ = value;
  // @@protoc_insertion_point(field_set:SubscribeNotificationNtf.message)
}

// required uint32 param1 = 2;
inline bool SubscribeNotificationNtf::has_param1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubscribeNotificationNtf::set_has_param1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubscribeNotificationNtf::clear_has_param1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubscribeNotificationNtf::clear_param1() {
  param1_ = 0u;
  clear_has_param1();
}
inline ::google::protobuf::uint32 SubscribeNotificationNtf::param1() const {
  // @@protoc_insertion_point(field_get:SubscribeNotificationNtf.param1)
  return param1_;
}
inline void SubscribeNotificationNtf::set_param1(::google::protobuf::uint32 value) {
  set_has_param1();
  param1_ = value;
  // @@protoc_insertion_point(field_set:SubscribeNotificationNtf.param1)
}

// required uint32 param2 = 3;
inline bool SubscribeNotificationNtf::has_param2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubscribeNotificationNtf::set_has_param2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubscribeNotificationNtf::clear_has_param2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubscribeNotificationNtf::clear_param2() {
  param2_ = 0u;
  clear_has_param2();
}
inline ::google::protobuf::uint32 SubscribeNotificationNtf::param2() const {
  // @@protoc_insertion_point(field_get:SubscribeNotificationNtf.param2)
  return param2_;
}
inline void SubscribeNotificationNtf::set_param2(::google::protobuf::uint32 value) {
  set_has_param2();
  param2_ = value;
  // @@protoc_insertion_point(field_set:SubscribeNotificationNtf.param2)
}

// required string str_msg1 = 4;
inline bool SubscribeNotificationNtf::has_str_msg1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubscribeNotificationNtf::set_has_str_msg1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubscribeNotificationNtf::clear_has_str_msg1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubscribeNotificationNtf::clear_str_msg1() {
  if (str_msg1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_msg1_->clear();
  }
  clear_has_str_msg1();
}
inline const ::std::string& SubscribeNotificationNtf::str_msg1() const {
  // @@protoc_insertion_point(field_get:SubscribeNotificationNtf.str_msg1)
  return *str_msg1_;
}
inline void SubscribeNotificationNtf::set_str_msg1(const ::std::string& value) {
  set_has_str_msg1();
  if (str_msg1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_msg1_ = new ::std::string;
  }
  str_msg1_->assign(value);
  // @@protoc_insertion_point(field_set:SubscribeNotificationNtf.str_msg1)
}
inline void SubscribeNotificationNtf::set_str_msg1(const char* value) {
  set_has_str_msg1();
  if (str_msg1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_msg1_ = new ::std::string;
  }
  str_msg1_->assign(value);
  // @@protoc_insertion_point(field_set_char:SubscribeNotificationNtf.str_msg1)
}
inline void SubscribeNotificationNtf::set_str_msg1(const char* value, size_t size) {
  set_has_str_msg1();
  if (str_msg1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_msg1_ = new ::std::string;
  }
  str_msg1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SubscribeNotificationNtf.str_msg1)
}
inline ::std::string* SubscribeNotificationNtf::mutable_str_msg1() {
  set_has_str_msg1();
  if (str_msg1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_msg1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SubscribeNotificationNtf.str_msg1)
  return str_msg1_;
}
inline ::std::string* SubscribeNotificationNtf::release_str_msg1() {
  clear_has_str_msg1();
  if (str_msg1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = str_msg1_;
    str_msg1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubscribeNotificationNtf::set_allocated_str_msg1(::std::string* str_msg1) {
  if (str_msg1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete str_msg1_;
  }
  if (str_msg1) {
    set_has_str_msg1();
    str_msg1_ = str_msg1;
  } else {
    clear_has_str_msg1();
    str_msg1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SubscribeNotificationNtf.str_msg1)
}

// required string str_msg2 = 5;
inline bool SubscribeNotificationNtf::has_str_msg2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubscribeNotificationNtf::set_has_str_msg2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubscribeNotificationNtf::clear_has_str_msg2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubscribeNotificationNtf::clear_str_msg2() {
  if (str_msg2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_msg2_->clear();
  }
  clear_has_str_msg2();
}
inline const ::std::string& SubscribeNotificationNtf::str_msg2() const {
  // @@protoc_insertion_point(field_get:SubscribeNotificationNtf.str_msg2)
  return *str_msg2_;
}
inline void SubscribeNotificationNtf::set_str_msg2(const ::std::string& value) {
  set_has_str_msg2();
  if (str_msg2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_msg2_ = new ::std::string;
  }
  str_msg2_->assign(value);
  // @@protoc_insertion_point(field_set:SubscribeNotificationNtf.str_msg2)
}
inline void SubscribeNotificationNtf::set_str_msg2(const char* value) {
  set_has_str_msg2();
  if (str_msg2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_msg2_ = new ::std::string;
  }
  str_msg2_->assign(value);
  // @@protoc_insertion_point(field_set_char:SubscribeNotificationNtf.str_msg2)
}
inline void SubscribeNotificationNtf::set_str_msg2(const char* value, size_t size) {
  set_has_str_msg2();
  if (str_msg2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_msg2_ = new ::std::string;
  }
  str_msg2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SubscribeNotificationNtf.str_msg2)
}
inline ::std::string* SubscribeNotificationNtf::mutable_str_msg2() {
  set_has_str_msg2();
  if (str_msg2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    str_msg2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SubscribeNotificationNtf.str_msg2)
  return str_msg2_;
}
inline ::std::string* SubscribeNotificationNtf::release_str_msg2() {
  clear_has_str_msg2();
  if (str_msg2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = str_msg2_;
    str_msg2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubscribeNotificationNtf::set_allocated_str_msg2(::std::string* str_msg2) {
  if (str_msg2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete str_msg2_;
  }
  if (str_msg2) {
    set_has_str_msg2();
    str_msg2_ = str_msg2;
  } else {
    clear_has_str_msg2();
    str_msg2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SubscribeNotificationNtf.str_msg2)
}

// required uint64 time = 6;
inline bool SubscribeNotificationNtf::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubscribeNotificationNtf::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubscribeNotificationNtf::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubscribeNotificationNtf::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 SubscribeNotificationNtf::time() const {
  // @@protoc_insertion_point(field_get:SubscribeNotificationNtf.time)
  return time_;
}
inline void SubscribeNotificationNtf::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:SubscribeNotificationNtf.time)
}

// -------------------------------------------------------------------

// DeviceBindingRqst

// required string valvectrl_id = 1;
inline bool DeviceBindingRqst::has_valvectrl_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceBindingRqst::set_has_valvectrl_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceBindingRqst::clear_has_valvectrl_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceBindingRqst::clear_valvectrl_id() {
  if (valvectrl_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    valvectrl_id_->clear();
  }
  clear_has_valvectrl_id();
}
inline const ::std::string& DeviceBindingRqst::valvectrl_id() const {
  // @@protoc_insertion_point(field_get:DeviceBindingRqst.valvectrl_id)
  return *valvectrl_id_;
}
inline void DeviceBindingRqst::set_valvectrl_id(const ::std::string& value) {
  set_has_valvectrl_id();
  if (valvectrl_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    valvectrl_id_ = new ::std::string;
  }
  valvectrl_id_->assign(value);
  // @@protoc_insertion_point(field_set:DeviceBindingRqst.valvectrl_id)
}
inline void DeviceBindingRqst::set_valvectrl_id(const char* value) {
  set_has_valvectrl_id();
  if (valvectrl_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    valvectrl_id_ = new ::std::string;
  }
  valvectrl_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DeviceBindingRqst.valvectrl_id)
}
inline void DeviceBindingRqst::set_valvectrl_id(const char* value, size_t size) {
  set_has_valvectrl_id();
  if (valvectrl_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    valvectrl_id_ = new ::std::string;
  }
  valvectrl_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DeviceBindingRqst.valvectrl_id)
}
inline ::std::string* DeviceBindingRqst::mutable_valvectrl_id() {
  set_has_valvectrl_id();
  if (valvectrl_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    valvectrl_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DeviceBindingRqst.valvectrl_id)
  return valvectrl_id_;
}
inline ::std::string* DeviceBindingRqst::release_valvectrl_id() {
  clear_has_valvectrl_id();
  if (valvectrl_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = valvectrl_id_;
    valvectrl_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeviceBindingRqst::set_allocated_valvectrl_id(::std::string* valvectrl_id) {
  if (valvectrl_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete valvectrl_id_;
  }
  if (valvectrl_id) {
    set_has_valvectrl_id();
    valvectrl_id_ = valvectrl_id;
  } else {
    clear_has_valvectrl_id();
    valvectrl_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DeviceBindingRqst.valvectrl_id)
}

// required string homegw_id = 2;
inline bool DeviceBindingRqst::has_homegw_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceBindingRqst::set_has_homegw_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceBindingRqst::clear_has_homegw_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceBindingRqst::clear_homegw_id() {
  if (homegw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homegw_id_->clear();
  }
  clear_has_homegw_id();
}
inline const ::std::string& DeviceBindingRqst::homegw_id() const {
  // @@protoc_insertion_point(field_get:DeviceBindingRqst.homegw_id)
  return *homegw_id_;
}
inline void DeviceBindingRqst::set_homegw_id(const ::std::string& value) {
  set_has_homegw_id();
  if (homegw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homegw_id_ = new ::std::string;
  }
  homegw_id_->assign(value);
  // @@protoc_insertion_point(field_set:DeviceBindingRqst.homegw_id)
}
inline void DeviceBindingRqst::set_homegw_id(const char* value) {
  set_has_homegw_id();
  if (homegw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homegw_id_ = new ::std::string;
  }
  homegw_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DeviceBindingRqst.homegw_id)
}
inline void DeviceBindingRqst::set_homegw_id(const char* value, size_t size) {
  set_has_homegw_id();
  if (homegw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homegw_id_ = new ::std::string;
  }
  homegw_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DeviceBindingRqst.homegw_id)
}
inline ::std::string* DeviceBindingRqst::mutable_homegw_id() {
  set_has_homegw_id();
  if (homegw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homegw_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DeviceBindingRqst.homegw_id)
  return homegw_id_;
}
inline ::std::string* DeviceBindingRqst::release_homegw_id() {
  clear_has_homegw_id();
  if (homegw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = homegw_id_;
    homegw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeviceBindingRqst::set_allocated_homegw_id(::std::string* homegw_id) {
  if (homegw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete homegw_id_;
  }
  if (homegw_id) {
    set_has_homegw_id();
    homegw_id_ = homegw_id;
  } else {
    clear_has_homegw_id();
    homegw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DeviceBindingRqst.homegw_id)
}

// -------------------------------------------------------------------

// RmDeviceBindingRqst

// required string valvectrl_id = 1;
inline bool RmDeviceBindingRqst::has_valvectrl_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RmDeviceBindingRqst::set_has_valvectrl_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RmDeviceBindingRqst::clear_has_valvectrl_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RmDeviceBindingRqst::clear_valvectrl_id() {
  if (valvectrl_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    valvectrl_id_->clear();
  }
  clear_has_valvectrl_id();
}
inline const ::std::string& RmDeviceBindingRqst::valvectrl_id() const {
  // @@protoc_insertion_point(field_get:RmDeviceBindingRqst.valvectrl_id)
  return *valvectrl_id_;
}
inline void RmDeviceBindingRqst::set_valvectrl_id(const ::std::string& value) {
  set_has_valvectrl_id();
  if (valvectrl_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    valvectrl_id_ = new ::std::string;
  }
  valvectrl_id_->assign(value);
  // @@protoc_insertion_point(field_set:RmDeviceBindingRqst.valvectrl_id)
}
inline void RmDeviceBindingRqst::set_valvectrl_id(const char* value) {
  set_has_valvectrl_id();
  if (valvectrl_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    valvectrl_id_ = new ::std::string;
  }
  valvectrl_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:RmDeviceBindingRqst.valvectrl_id)
}
inline void RmDeviceBindingRqst::set_valvectrl_id(const char* value, size_t size) {
  set_has_valvectrl_id();
  if (valvectrl_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    valvectrl_id_ = new ::std::string;
  }
  valvectrl_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RmDeviceBindingRqst.valvectrl_id)
}
inline ::std::string* RmDeviceBindingRqst::mutable_valvectrl_id() {
  set_has_valvectrl_id();
  if (valvectrl_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    valvectrl_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RmDeviceBindingRqst.valvectrl_id)
  return valvectrl_id_;
}
inline ::std::string* RmDeviceBindingRqst::release_valvectrl_id() {
  clear_has_valvectrl_id();
  if (valvectrl_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = valvectrl_id_;
    valvectrl_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmDeviceBindingRqst::set_allocated_valvectrl_id(::std::string* valvectrl_id) {
  if (valvectrl_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete valvectrl_id_;
  }
  if (valvectrl_id) {
    set_has_valvectrl_id();
    valvectrl_id_ = valvectrl_id;
  } else {
    clear_has_valvectrl_id();
    valvectrl_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RmDeviceBindingRqst.valvectrl_id)
}

// required string homegw_id = 2;
inline bool RmDeviceBindingRqst::has_homegw_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RmDeviceBindingRqst::set_has_homegw_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RmDeviceBindingRqst::clear_has_homegw_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RmDeviceBindingRqst::clear_homegw_id() {
  if (homegw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homegw_id_->clear();
  }
  clear_has_homegw_id();
}
inline const ::std::string& RmDeviceBindingRqst::homegw_id() const {
  // @@protoc_insertion_point(field_get:RmDeviceBindingRqst.homegw_id)
  return *homegw_id_;
}
inline void RmDeviceBindingRqst::set_homegw_id(const ::std::string& value) {
  set_has_homegw_id();
  if (homegw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homegw_id_ = new ::std::string;
  }
  homegw_id_->assign(value);
  // @@protoc_insertion_point(field_set:RmDeviceBindingRqst.homegw_id)
}
inline void RmDeviceBindingRqst::set_homegw_id(const char* value) {
  set_has_homegw_id();
  if (homegw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homegw_id_ = new ::std::string;
  }
  homegw_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:RmDeviceBindingRqst.homegw_id)
}
inline void RmDeviceBindingRqst::set_homegw_id(const char* value, size_t size) {
  set_has_homegw_id();
  if (homegw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homegw_id_ = new ::std::string;
  }
  homegw_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RmDeviceBindingRqst.homegw_id)
}
inline ::std::string* RmDeviceBindingRqst::mutable_homegw_id() {
  set_has_homegw_id();
  if (homegw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homegw_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RmDeviceBindingRqst.homegw_id)
  return homegw_id_;
}
inline ::std::string* RmDeviceBindingRqst::release_homegw_id() {
  clear_has_homegw_id();
  if (homegw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = homegw_id_;
    homegw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmDeviceBindingRqst::set_allocated_homegw_id(::std::string* homegw_id) {
  if (homegw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete homegw_id_;
  }
  if (homegw_id) {
    set_has_homegw_id();
    homegw_id_ = homegw_id;
  } else {
    clear_has_homegw_id();
    homegw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RmDeviceBindingRqst.homegw_id)
}

// -------------------------------------------------------------------

// RequestNodeDataUploadNtf

// required string node_id = 1;
inline bool RequestNodeDataUploadNtf::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestNodeDataUploadNtf::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestNodeDataUploadNtf::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestNodeDataUploadNtf::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& RequestNodeDataUploadNtf::node_id() const {
  // @@protoc_insertion_point(field_get:RequestNodeDataUploadNtf.node_id)
  return *node_id_;
}
inline void RequestNodeDataUploadNtf::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:RequestNodeDataUploadNtf.node_id)
}
inline void RequestNodeDataUploadNtf::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:RequestNodeDataUploadNtf.node_id)
}
inline void RequestNodeDataUploadNtf::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RequestNodeDataUploadNtf.node_id)
}
inline ::std::string* RequestNodeDataUploadNtf::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RequestNodeDataUploadNtf.node_id)
  return node_id_;
}
inline ::std::string* RequestNodeDataUploadNtf::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestNodeDataUploadNtf::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RequestNodeDataUploadNtf.node_id)
}

// required .DataType type = 2;
inline bool RequestNodeDataUploadNtf::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestNodeDataUploadNtf::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestNodeDataUploadNtf::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestNodeDataUploadNtf::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::DataType RequestNodeDataUploadNtf::type() const {
  // @@protoc_insertion_point(field_get:RequestNodeDataUploadNtf.type)
  return static_cast< ::DataType >(type_);
}
inline void RequestNodeDataUploadNtf::set_type(::DataType value) {
  assert(::DataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:RequestNodeDataUploadNtf.type)
}

// repeated .SensorData data = 3;
inline int RequestNodeDataUploadNtf::data_size() const {
  return data_.size();
}
inline void RequestNodeDataUploadNtf::clear_data() {
  data_.Clear();
}
inline const ::SensorData& RequestNodeDataUploadNtf::data(int index) const {
  // @@protoc_insertion_point(field_get:RequestNodeDataUploadNtf.data)
  return data_.Get(index);
}
inline ::SensorData* RequestNodeDataUploadNtf::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:RequestNodeDataUploadNtf.data)
  return data_.Mutable(index);
}
inline ::SensorData* RequestNodeDataUploadNtf::add_data() {
  // @@protoc_insertion_point(field_add:RequestNodeDataUploadNtf.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SensorData >&
RequestNodeDataUploadNtf::data() const {
  // @@protoc_insertion_point(field_list:RequestNodeDataUploadNtf.data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::SensorData >*
RequestNodeDataUploadNtf::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:RequestNodeDataUploadNtf.data)
  return &data_;
}

// -------------------------------------------------------------------

// SensorData

// required uint32 sensor_no = 1;
inline bool SensorData::has_sensor_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorData::set_has_sensor_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorData::clear_has_sensor_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorData::clear_sensor_no() {
  sensor_no_ = 0u;
  clear_has_sensor_no();
}
inline ::google::protobuf::uint32 SensorData::sensor_no() const {
  // @@protoc_insertion_point(field_get:SensorData.sensor_no)
  return sensor_no_;
}
inline void SensorData::set_sensor_no(::google::protobuf::uint32 value) {
  set_has_sensor_no();
  sensor_no_ = value;
  // @@protoc_insertion_point(field_set:SensorData.sensor_no)
}

// required uint32 type = 2;
inline bool SensorData::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorData::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorData::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 SensorData::type() const {
  // @@protoc_insertion_point(field_get:SensorData.type)
  return type_;
}
inline void SensorData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SensorData.type)
}

// required float data = 3;
inline bool SensorData::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorData::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorData::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorData::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline float SensorData::data() const {
  // @@protoc_insertion_point(field_get:SensorData.data)
  return data_;
}
inline void SensorData::set_data(float value) {
  set_has_data();
  data_ = value;
  // @@protoc_insertion_point(field_set:SensorData.data)
}

// optional float reserved = 4;
inline bool SensorData::has_reserved() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorData::set_has_reserved() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorData::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorData::clear_reserved() {
  reserved_ = 0;
  clear_has_reserved();
}
inline float SensorData::reserved() const {
  // @@protoc_insertion_point(field_get:SensorData.reserved)
  return reserved_;
}
inline void SensorData::set_reserved(float value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:SensorData.reserved)
}

// required uint64 time = 5;
inline bool SensorData::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorData::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorData::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorData::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 SensorData::time() const {
  // @@protoc_insertion_point(field_get:SensorData.time)
  return time_;
}
inline void SensorData::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:SensorData.time)
}

// -------------------------------------------------------------------

// NmpDataUploadNtf

// required string node_id = 1;
inline bool NmpDataUploadNtf::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NmpDataUploadNtf::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NmpDataUploadNtf::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NmpDataUploadNtf::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& NmpDataUploadNtf::node_id() const {
  // @@protoc_insertion_point(field_get:NmpDataUploadNtf.node_id)
  return *node_id_;
}
inline void NmpDataUploadNtf::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:NmpDataUploadNtf.node_id)
}
inline void NmpDataUploadNtf::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:NmpDataUploadNtf.node_id)
}
inline void NmpDataUploadNtf::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NmpDataUploadNtf.node_id)
}
inline ::std::string* NmpDataUploadNtf::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NmpDataUploadNtf.node_id)
  return node_id_;
}
inline ::std::string* NmpDataUploadNtf::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NmpDataUploadNtf::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NmpDataUploadNtf.node_id)
}

// required bytes nmp_data = 2;
inline bool NmpDataUploadNtf::has_nmp_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NmpDataUploadNtf::set_has_nmp_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NmpDataUploadNtf::clear_has_nmp_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NmpDataUploadNtf::clear_nmp_data() {
  if (nmp_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nmp_data_->clear();
  }
  clear_has_nmp_data();
}
inline const ::std::string& NmpDataUploadNtf::nmp_data() const {
  // @@protoc_insertion_point(field_get:NmpDataUploadNtf.nmp_data)
  return *nmp_data_;
}
inline void NmpDataUploadNtf::set_nmp_data(const ::std::string& value) {
  set_has_nmp_data();
  if (nmp_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nmp_data_ = new ::std::string;
  }
  nmp_data_->assign(value);
  // @@protoc_insertion_point(field_set:NmpDataUploadNtf.nmp_data)
}
inline void NmpDataUploadNtf::set_nmp_data(const char* value) {
  set_has_nmp_data();
  if (nmp_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nmp_data_ = new ::std::string;
  }
  nmp_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:NmpDataUploadNtf.nmp_data)
}
inline void NmpDataUploadNtf::set_nmp_data(const void* value, size_t size) {
  set_has_nmp_data();
  if (nmp_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nmp_data_ = new ::std::string;
  }
  nmp_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NmpDataUploadNtf.nmp_data)
}
inline ::std::string* NmpDataUploadNtf::mutable_nmp_data() {
  set_has_nmp_data();
  if (nmp_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nmp_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NmpDataUploadNtf.nmp_data)
  return nmp_data_;
}
inline ::std::string* NmpDataUploadNtf::release_nmp_data() {
  clear_has_nmp_data();
  if (nmp_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nmp_data_;
    nmp_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NmpDataUploadNtf::set_allocated_nmp_data(::std::string* nmp_data) {
  if (nmp_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nmp_data_;
  }
  if (nmp_data) {
    set_has_nmp_data();
    nmp_data_ = nmp_data;
  } else {
    clear_has_nmp_data();
    nmp_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NmpDataUploadNtf.nmp_data)
}

// -------------------------------------------------------------------

// ContinueNtf

// required uint32 seq = 1;
inline bool ContinueNtf::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContinueNtf::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContinueNtf::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContinueNtf::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 ContinueNtf::seq() const {
  // @@protoc_insertion_point(field_get:ContinueNtf.seq)
  return seq_;
}
inline void ContinueNtf::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:ContinueNtf.seq)
}

// -------------------------------------------------------------------

// GetNodeRealDataRqst

// required bytes node_id = 1;
inline bool GetNodeRealDataRqst::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNodeRealDataRqst::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNodeRealDataRqst::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNodeRealDataRqst::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& GetNodeRealDataRqst::node_id() const {
  // @@protoc_insertion_point(field_get:GetNodeRealDataRqst.node_id)
  return *node_id_;
}
inline void GetNodeRealDataRqst::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:GetNodeRealDataRqst.node_id)
}
inline void GetNodeRealDataRqst::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNodeRealDataRqst.node_id)
}
inline void GetNodeRealDataRqst::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNodeRealDataRqst.node_id)
}
inline ::std::string* GetNodeRealDataRqst::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNodeRealDataRqst.node_id)
  return node_id_;
}
inline ::std::string* GetNodeRealDataRqst::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNodeRealDataRqst::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNodeRealDataRqst.node_id)
}

// required uint32 sensor_no = 2;
inline bool GetNodeRealDataRqst::has_sensor_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetNodeRealDataRqst::set_has_sensor_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetNodeRealDataRqst::clear_has_sensor_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetNodeRealDataRqst::clear_sensor_no() {
  sensor_no_ = 0u;
  clear_has_sensor_no();
}
inline ::google::protobuf::uint32 GetNodeRealDataRqst::sensor_no() const {
  // @@protoc_insertion_point(field_get:GetNodeRealDataRqst.sensor_no)
  return sensor_no_;
}
inline void GetNodeRealDataRqst::set_sensor_no(::google::protobuf::uint32 value) {
  set_has_sensor_no();
  sensor_no_ = value;
  // @@protoc_insertion_point(field_set:GetNodeRealDataRqst.sensor_no)
}

// required uint32 timeout = 3;
inline bool GetNodeRealDataRqst::has_timeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetNodeRealDataRqst::set_has_timeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetNodeRealDataRqst::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetNodeRealDataRqst::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 GetNodeRealDataRqst::timeout() const {
  // @@protoc_insertion_point(field_get:GetNodeRealDataRqst.timeout)
  return timeout_;
}
inline void GetNodeRealDataRqst::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:GetNodeRealDataRqst.timeout)
}

// -------------------------------------------------------------------

// GetNodeRealDataRsps

// required bytes node_id = 1;
inline bool GetNodeRealDataRsps::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNodeRealDataRsps::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNodeRealDataRsps::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNodeRealDataRsps::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& GetNodeRealDataRsps::node_id() const {
  // @@protoc_insertion_point(field_get:GetNodeRealDataRsps.node_id)
  return *node_id_;
}
inline void GetNodeRealDataRsps::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:GetNodeRealDataRsps.node_id)
}
inline void GetNodeRealDataRsps::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNodeRealDataRsps.node_id)
}
inline void GetNodeRealDataRsps::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNodeRealDataRsps.node_id)
}
inline ::std::string* GetNodeRealDataRsps::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNodeRealDataRsps.node_id)
  return node_id_;
}
inline ::std::string* GetNodeRealDataRsps::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNodeRealDataRsps::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNodeRealDataRsps.node_id)
}

// required .DataType type = 2;
inline bool GetNodeRealDataRsps::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetNodeRealDataRsps::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetNodeRealDataRsps::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetNodeRealDataRsps::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::DataType GetNodeRealDataRsps::type() const {
  // @@protoc_insertion_point(field_get:GetNodeRealDataRsps.type)
  return static_cast< ::DataType >(type_);
}
inline void GetNodeRealDataRsps::set_type(::DataType value) {
  assert(::DataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:GetNodeRealDataRsps.type)
}

// repeated .SensorData s_data = 3;
inline int GetNodeRealDataRsps::s_data_size() const {
  return s_data_.size();
}
inline void GetNodeRealDataRsps::clear_s_data() {
  s_data_.Clear();
}
inline const ::SensorData& GetNodeRealDataRsps::s_data(int index) const {
  // @@protoc_insertion_point(field_get:GetNodeRealDataRsps.s_data)
  return s_data_.Get(index);
}
inline ::SensorData* GetNodeRealDataRsps::mutable_s_data(int index) {
  // @@protoc_insertion_point(field_mutable:GetNodeRealDataRsps.s_data)
  return s_data_.Mutable(index);
}
inline ::SensorData* GetNodeRealDataRsps::add_s_data() {
  // @@protoc_insertion_point(field_add:GetNodeRealDataRsps.s_data)
  return s_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SensorData >&
GetNodeRealDataRsps::s_data() const {
  // @@protoc_insertion_point(field_list:GetNodeRealDataRsps.s_data)
  return s_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::SensorData >*
GetNodeRealDataRsps::mutable_s_data() {
  // @@protoc_insertion_point(field_mutable_list:GetNodeRealDataRsps.s_data)
  return &s_data_;
}

// -------------------------------------------------------------------

// SetCommandToNodeRqst

// required string node_id = 1;
inline bool SetCommandToNodeRqst::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetCommandToNodeRqst::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetCommandToNodeRqst::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetCommandToNodeRqst::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& SetCommandToNodeRqst::node_id() const {
  // @@protoc_insertion_point(field_get:SetCommandToNodeRqst.node_id)
  return *node_id_;
}
inline void SetCommandToNodeRqst::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:SetCommandToNodeRqst.node_id)
}
inline void SetCommandToNodeRqst::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:SetCommandToNodeRqst.node_id)
}
inline void SetCommandToNodeRqst::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetCommandToNodeRqst.node_id)
}
inline ::std::string* SetCommandToNodeRqst::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SetCommandToNodeRqst.node_id)
  return node_id_;
}
inline ::std::string* SetCommandToNodeRqst::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetCommandToNodeRqst::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SetCommandToNodeRqst.node_id)
}

// required .SetCommandToNodeRqst.Command cmd = 2;
inline bool SetCommandToNodeRqst::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetCommandToNodeRqst::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetCommandToNodeRqst::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetCommandToNodeRqst::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::SetCommandToNodeRqst_Command SetCommandToNodeRqst::cmd() const {
  // @@protoc_insertion_point(field_get:SetCommandToNodeRqst.cmd)
  return static_cast< ::SetCommandToNodeRqst_Command >(cmd_);
}
inline void SetCommandToNodeRqst::set_cmd(::SetCommandToNodeRqst_Command value) {
  assert(::SetCommandToNodeRqst_Command_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:SetCommandToNodeRqst.cmd)
}

// optional uint32 sub_type = 3;
inline bool SetCommandToNodeRqst::has_sub_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetCommandToNodeRqst::set_has_sub_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetCommandToNodeRqst::clear_has_sub_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetCommandToNodeRqst::clear_sub_type() {
  sub_type_ = 0u;
  clear_has_sub_type();
}
inline ::google::protobuf::uint32 SetCommandToNodeRqst::sub_type() const {
  // @@protoc_insertion_point(field_get:SetCommandToNodeRqst.sub_type)
  return sub_type_;
}
inline void SetCommandToNodeRqst::set_sub_type(::google::protobuf::uint32 value) {
  set_has_sub_type();
  sub_type_ = value;
  // @@protoc_insertion_point(field_set:SetCommandToNodeRqst.sub_type)
}

// optional .TypeData node_data = 4;
inline bool SetCommandToNodeRqst::has_node_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetCommandToNodeRqst::set_has_node_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetCommandToNodeRqst::clear_has_node_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetCommandToNodeRqst::clear_node_data() {
  if (node_data_ != NULL) node_data_->::TypeData::Clear();
  clear_has_node_data();
}
inline const ::TypeData& SetCommandToNodeRqst::node_data() const {
  // @@protoc_insertion_point(field_get:SetCommandToNodeRqst.node_data)
  return node_data_ != NULL ? *node_data_ : *default_instance_->node_data_;
}
inline ::TypeData* SetCommandToNodeRqst::mutable_node_data() {
  set_has_node_data();
  if (node_data_ == NULL) node_data_ = new ::TypeData;
  // @@protoc_insertion_point(field_mutable:SetCommandToNodeRqst.node_data)
  return node_data_;
}
inline ::TypeData* SetCommandToNodeRqst::release_node_data() {
  clear_has_node_data();
  ::TypeData* temp = node_data_;
  node_data_ = NULL;
  return temp;
}
inline void SetCommandToNodeRqst::set_allocated_node_data(::TypeData* node_data) {
  delete node_data_;
  node_data_ = node_data;
  if (node_data) {
    set_has_node_data();
  } else {
    clear_has_node_data();
  }
  // @@protoc_insertion_point(field_set_allocated:SetCommandToNodeRqst.node_data)
}

// repeated .SensorTypeData sensor_data_list = 5;
inline int SetCommandToNodeRqst::sensor_data_list_size() const {
  return sensor_data_list_.size();
}
inline void SetCommandToNodeRqst::clear_sensor_data_list() {
  sensor_data_list_.Clear();
}
inline const ::SensorTypeData& SetCommandToNodeRqst::sensor_data_list(int index) const {
  // @@protoc_insertion_point(field_get:SetCommandToNodeRqst.sensor_data_list)
  return sensor_data_list_.Get(index);
}
inline ::SensorTypeData* SetCommandToNodeRqst::mutable_sensor_data_list(int index) {
  // @@protoc_insertion_point(field_mutable:SetCommandToNodeRqst.sensor_data_list)
  return sensor_data_list_.Mutable(index);
}
inline ::SensorTypeData* SetCommandToNodeRqst::add_sensor_data_list() {
  // @@protoc_insertion_point(field_add:SetCommandToNodeRqst.sensor_data_list)
  return sensor_data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SensorTypeData >&
SetCommandToNodeRqst::sensor_data_list() const {
  // @@protoc_insertion_point(field_list:SetCommandToNodeRqst.sensor_data_list)
  return sensor_data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::SensorTypeData >*
SetCommandToNodeRqst::mutable_sensor_data_list() {
  // @@protoc_insertion_point(field_mutable_list:SetCommandToNodeRqst.sensor_data_list)
  return &sensor_data_list_;
}

// -------------------------------------------------------------------

// TypeData

// optional uint32 type = 1;
inline bool TypeData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TypeData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TypeData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TypeData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 TypeData::type() const {
  // @@protoc_insertion_point(field_get:TypeData.type)
  return type_;
}
inline void TypeData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:TypeData.type)
}

// required float data = 2;
inline bool TypeData::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TypeData::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TypeData::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TypeData::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline float TypeData::data() const {
  // @@protoc_insertion_point(field_get:TypeData.data)
  return data_;
}
inline void TypeData::set_data(float value) {
  set_has_data();
  data_ = value;
  // @@protoc_insertion_point(field_set:TypeData.data)
}

// -------------------------------------------------------------------

// SensorTypeData

// required uint32 sensor_no = 1;
inline bool SensorTypeData::has_sensor_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorTypeData::set_has_sensor_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorTypeData::clear_has_sensor_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorTypeData::clear_sensor_no() {
  sensor_no_ = 0u;
  clear_has_sensor_no();
}
inline ::google::protobuf::uint32 SensorTypeData::sensor_no() const {
  // @@protoc_insertion_point(field_get:SensorTypeData.sensor_no)
  return sensor_no_;
}
inline void SensorTypeData::set_sensor_no(::google::protobuf::uint32 value) {
  set_has_sensor_no();
  sensor_no_ = value;
  // @@protoc_insertion_point(field_set:SensorTypeData.sensor_no)
}

// optional uint32 type = 2;
inline bool SensorTypeData::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorTypeData::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorTypeData::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorTypeData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 SensorTypeData::type() const {
  // @@protoc_insertion_point(field_get:SensorTypeData.type)
  return type_;
}
inline void SensorTypeData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SensorTypeData.type)
}

// required float data = 3;
inline bool SensorTypeData::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorTypeData::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorTypeData::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorTypeData::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline float SensorTypeData::data() const {
  // @@protoc_insertion_point(field_get:SensorTypeData.data)
  return data_;
}
inline void SensorTypeData::set_data(float value) {
  set_has_data();
  data_ = value;
  // @@protoc_insertion_point(field_set:SensorTypeData.data)
}

// -------------------------------------------------------------------

// GetNodeSettingsRqst

// required string node_id = 1;
inline bool GetNodeSettingsRqst::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNodeSettingsRqst::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNodeSettingsRqst::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNodeSettingsRqst::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& GetNodeSettingsRqst::node_id() const {
  // @@protoc_insertion_point(field_get:GetNodeSettingsRqst.node_id)
  return *node_id_;
}
inline void GetNodeSettingsRqst::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:GetNodeSettingsRqst.node_id)
}
inline void GetNodeSettingsRqst::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetNodeSettingsRqst.node_id)
}
inline void GetNodeSettingsRqst::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetNodeSettingsRqst.node_id)
}
inline ::std::string* GetNodeSettingsRqst::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetNodeSettingsRqst.node_id)
  return node_id_;
}
inline ::std::string* GetNodeSettingsRqst::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetNodeSettingsRqst::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetNodeSettingsRqst.node_id)
}

// required .GetNodeSettingsRqst.Command cmd = 2;
inline bool GetNodeSettingsRqst::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetNodeSettingsRqst::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetNodeSettingsRqst::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetNodeSettingsRqst::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::GetNodeSettingsRqst_Command GetNodeSettingsRqst::cmd() const {
  // @@protoc_insertion_point(field_get:GetNodeSettingsRqst.cmd)
  return static_cast< ::GetNodeSettingsRqst_Command >(cmd_);
}
inline void GetNodeSettingsRqst::set_cmd(::GetNodeSettingsRqst_Command value) {
  assert(::GetNodeSettingsRqst_Command_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:GetNodeSettingsRqst.cmd)
}

// optional uint32 sub_type = 3;
inline bool GetNodeSettingsRqst::has_sub_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetNodeSettingsRqst::set_has_sub_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetNodeSettingsRqst::clear_has_sub_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetNodeSettingsRqst::clear_sub_type() {
  sub_type_ = 0u;
  clear_has_sub_type();
}
inline ::google::protobuf::uint32 GetNodeSettingsRqst::sub_type() const {
  // @@protoc_insertion_point(field_get:GetNodeSettingsRqst.sub_type)
  return sub_type_;
}
inline void GetNodeSettingsRqst::set_sub_type(::google::protobuf::uint32 value) {
  set_has_sub_type();
  sub_type_ = value;
  // @@protoc_insertion_point(field_set:GetNodeSettingsRqst.sub_type)
}

// required uint32 sensor_no = 4;
inline bool GetNodeSettingsRqst::has_sensor_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetNodeSettingsRqst::set_has_sensor_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetNodeSettingsRqst::clear_has_sensor_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetNodeSettingsRqst::clear_sensor_no() {
  sensor_no_ = 0u;
  clear_has_sensor_no();
}
inline ::google::protobuf::uint32 GetNodeSettingsRqst::sensor_no() const {
  // @@protoc_insertion_point(field_get:GetNodeSettingsRqst.sensor_no)
  return sensor_no_;
}
inline void GetNodeSettingsRqst::set_sensor_no(::google::protobuf::uint32 value) {
  set_has_sensor_no();
  sensor_no_ = value;
  // @@protoc_insertion_point(field_set:GetNodeSettingsRqst.sensor_no)
}

// -------------------------------------------------------------------

// GetNodeSettingsRsps

// optional .TypeData node_data = 1;
inline bool GetNodeSettingsRsps::has_node_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNodeSettingsRsps::set_has_node_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNodeSettingsRsps::clear_has_node_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNodeSettingsRsps::clear_node_data() {
  if (node_data_ != NULL) node_data_->::TypeData::Clear();
  clear_has_node_data();
}
inline const ::TypeData& GetNodeSettingsRsps::node_data() const {
  // @@protoc_insertion_point(field_get:GetNodeSettingsRsps.node_data)
  return node_data_ != NULL ? *node_data_ : *default_instance_->node_data_;
}
inline ::TypeData* GetNodeSettingsRsps::mutable_node_data() {
  set_has_node_data();
  if (node_data_ == NULL) node_data_ = new ::TypeData;
  // @@protoc_insertion_point(field_mutable:GetNodeSettingsRsps.node_data)
  return node_data_;
}
inline ::TypeData* GetNodeSettingsRsps::release_node_data() {
  clear_has_node_data();
  ::TypeData* temp = node_data_;
  node_data_ = NULL;
  return temp;
}
inline void GetNodeSettingsRsps::set_allocated_node_data(::TypeData* node_data) {
  delete node_data_;
  node_data_ = node_data;
  if (node_data) {
    set_has_node_data();
  } else {
    clear_has_node_data();
  }
  // @@protoc_insertion_point(field_set_allocated:GetNodeSettingsRsps.node_data)
}

// repeated .SensorTypeData sensor_data_list = 2;
inline int GetNodeSettingsRsps::sensor_data_list_size() const {
  return sensor_data_list_.size();
}
inline void GetNodeSettingsRsps::clear_sensor_data_list() {
  sensor_data_list_.Clear();
}
inline const ::SensorTypeData& GetNodeSettingsRsps::sensor_data_list(int index) const {
  // @@protoc_insertion_point(field_get:GetNodeSettingsRsps.sensor_data_list)
  return sensor_data_list_.Get(index);
}
inline ::SensorTypeData* GetNodeSettingsRsps::mutable_sensor_data_list(int index) {
  // @@protoc_insertion_point(field_mutable:GetNodeSettingsRsps.sensor_data_list)
  return sensor_data_list_.Mutable(index);
}
inline ::SensorTypeData* GetNodeSettingsRsps::add_sensor_data_list() {
  // @@protoc_insertion_point(field_add:GetNodeSettingsRsps.sensor_data_list)
  return sensor_data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SensorTypeData >&
GetNodeSettingsRsps::sensor_data_list() const {
  // @@protoc_insertion_point(field_list:GetNodeSettingsRsps.sensor_data_list)
  return sensor_data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::SensorTypeData >*
GetNodeSettingsRsps::mutable_sensor_data_list() {
  // @@protoc_insertion_point(field_mutable_list:GetNodeSettingsRsps.sensor_data_list)
  return &sensor_data_list_;
}

// -------------------------------------------------------------------

// GetUpDisconCachedAlarmRqst

// required uint64 begin_time = 1;
inline bool GetUpDisconCachedAlarmRqst::has_begin_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUpDisconCachedAlarmRqst::set_has_begin_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUpDisconCachedAlarmRqst::clear_has_begin_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUpDisconCachedAlarmRqst::clear_begin_time() {
  begin_time_ = GOOGLE_ULONGLONG(0);
  clear_has_begin_time();
}
inline ::google::protobuf::uint64 GetUpDisconCachedAlarmRqst::begin_time() const {
  // @@protoc_insertion_point(field_get:GetUpDisconCachedAlarmRqst.begin_time)
  return begin_time_;
}
inline void GetUpDisconCachedAlarmRqst::set_begin_time(::google::protobuf::uint64 value) {
  set_has_begin_time();
  begin_time_ = value;
  // @@protoc_insertion_point(field_set:GetUpDisconCachedAlarmRqst.begin_time)
}

// required uint64 end_time = 2;
inline bool GetUpDisconCachedAlarmRqst::has_end_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUpDisconCachedAlarmRqst::set_has_end_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUpDisconCachedAlarmRqst::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUpDisconCachedAlarmRqst::clear_end_time() {
  end_time_ = GOOGLE_ULONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::uint64 GetUpDisconCachedAlarmRqst::end_time() const {
  // @@protoc_insertion_point(field_get:GetUpDisconCachedAlarmRqst.end_time)
  return end_time_;
}
inline void GetUpDisconCachedAlarmRqst::set_end_time(::google::protobuf::uint64 value) {
  set_has_end_time();
  end_time_ = value;
  // @@protoc_insertion_point(field_set:GetUpDisconCachedAlarmRqst.end_time)
}

// required uint32 count = 3;
inline bool GetUpDisconCachedAlarmRqst::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUpDisconCachedAlarmRqst::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUpDisconCachedAlarmRqst::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUpDisconCachedAlarmRqst::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 GetUpDisconCachedAlarmRqst::count() const {
  // @@protoc_insertion_point(field_get:GetUpDisconCachedAlarmRqst.count)
  return count_;
}
inline void GetUpDisconCachedAlarmRqst::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:GetUpDisconCachedAlarmRqst.count)
}

// -------------------------------------------------------------------

// GetUpDisconCachedAlarmRsps

// repeated .CachedAlarmData data = 1;
inline int GetUpDisconCachedAlarmRsps::data_size() const {
  return data_.size();
}
inline void GetUpDisconCachedAlarmRsps::clear_data() {
  data_.Clear();
}
inline const ::CachedAlarmData& GetUpDisconCachedAlarmRsps::data(int index) const {
  // @@protoc_insertion_point(field_get:GetUpDisconCachedAlarmRsps.data)
  return data_.Get(index);
}
inline ::CachedAlarmData* GetUpDisconCachedAlarmRsps::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:GetUpDisconCachedAlarmRsps.data)
  return data_.Mutable(index);
}
inline ::CachedAlarmData* GetUpDisconCachedAlarmRsps::add_data() {
  // @@protoc_insertion_point(field_add:GetUpDisconCachedAlarmRsps.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CachedAlarmData >&
GetUpDisconCachedAlarmRsps::data() const {
  // @@protoc_insertion_point(field_list:GetUpDisconCachedAlarmRsps.data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::CachedAlarmData >*
GetUpDisconCachedAlarmRsps::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:GetUpDisconCachedAlarmRsps.data)
  return &data_;
}

// -------------------------------------------------------------------

// CachedAlarmData

// required bytes node_id = 1;
inline bool CachedAlarmData::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CachedAlarmData::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CachedAlarmData::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CachedAlarmData::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& CachedAlarmData::node_id() const {
  // @@protoc_insertion_point(field_get:CachedAlarmData.node_id)
  return *node_id_;
}
inline void CachedAlarmData::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:CachedAlarmData.node_id)
}
inline void CachedAlarmData::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:CachedAlarmData.node_id)
}
inline void CachedAlarmData::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CachedAlarmData.node_id)
}
inline ::std::string* CachedAlarmData::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CachedAlarmData.node_id)
  return node_id_;
}
inline ::std::string* CachedAlarmData::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CachedAlarmData::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CachedAlarmData.node_id)
}

// required uint32 sensor_no = 2;
inline bool CachedAlarmData::has_sensor_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CachedAlarmData::set_has_sensor_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CachedAlarmData::clear_has_sensor_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CachedAlarmData::clear_sensor_no() {
  sensor_no_ = 0u;
  clear_has_sensor_no();
}
inline ::google::protobuf::uint32 CachedAlarmData::sensor_no() const {
  // @@protoc_insertion_point(field_get:CachedAlarmData.sensor_no)
  return sensor_no_;
}
inline void CachedAlarmData::set_sensor_no(::google::protobuf::uint32 value) {
  set_has_sensor_no();
  sensor_no_ = value;
  // @@protoc_insertion_point(field_set:CachedAlarmData.sensor_no)
}

// required .DataType type = 3;
inline bool CachedAlarmData::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CachedAlarmData::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CachedAlarmData::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CachedAlarmData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::DataType CachedAlarmData::type() const {
  // @@protoc_insertion_point(field_get:CachedAlarmData.type)
  return static_cast< ::DataType >(type_);
}
inline void CachedAlarmData::set_type(::DataType value) {
  assert(::DataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:CachedAlarmData.type)
}

// required float data = 4;
inline bool CachedAlarmData::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CachedAlarmData::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CachedAlarmData::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CachedAlarmData::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline float CachedAlarmData::data() const {
  // @@protoc_insertion_point(field_get:CachedAlarmData.data)
  return data_;
}
inline void CachedAlarmData::set_data(float value) {
  set_has_data();
  data_ = value;
  // @@protoc_insertion_point(field_set:CachedAlarmData.data)
}

// optional uint32 reserved = 5;
inline bool CachedAlarmData::has_reserved() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CachedAlarmData::set_has_reserved() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CachedAlarmData::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CachedAlarmData::clear_reserved() {
  reserved_ = 0u;
  clear_has_reserved();
}
inline ::google::protobuf::uint32 CachedAlarmData::reserved() const {
  // @@protoc_insertion_point(field_get:CachedAlarmData.reserved)
  return reserved_;
}
inline void CachedAlarmData::set_reserved(::google::protobuf::uint32 value) {
  set_has_reserved();
  reserved_ = value;
  // @@protoc_insertion_point(field_set:CachedAlarmData.reserved)
}

// required uint64 time = 6;
inline bool CachedAlarmData::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CachedAlarmData::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CachedAlarmData::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CachedAlarmData::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 CachedAlarmData::time() const {
  // @@protoc_insertion_point(field_get:CachedAlarmData.time)
  return time_;
}
inline void CachedAlarmData::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:CachedAlarmData.time)
}

// -------------------------------------------------------------------

// SubscribeAllNodeDataRqst

// required .DataType type = 1;
inline bool SubscribeAllNodeDataRqst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeAllNodeDataRqst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeAllNodeDataRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeAllNodeDataRqst::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::DataType SubscribeAllNodeDataRqst::type() const {
  // @@protoc_insertion_point(field_get:SubscribeAllNodeDataRqst.type)
  return static_cast< ::DataType >(type_);
}
inline void SubscribeAllNodeDataRqst::set_type(::DataType value) {
  assert(::DataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SubscribeAllNodeDataRqst.type)
}

// -------------------------------------------------------------------

// CancelAllNodeDataRqst

// required .DataType type = 1;
inline bool CancelAllNodeDataRqst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelAllNodeDataRqst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelAllNodeDataRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelAllNodeDataRqst::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::DataType CancelAllNodeDataRqst::type() const {
  // @@protoc_insertion_point(field_get:CancelAllNodeDataRqst.type)
  return static_cast< ::DataType >(type_);
}
inline void CancelAllNodeDataRqst::set_type(::DataType value) {
  assert(::DataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:CancelAllNodeDataRqst.type)
}

// -------------------------------------------------------------------

// BatSubscribeNodeDataRqst

// required .DataType type = 1;
inline bool BatSubscribeNodeDataRqst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatSubscribeNodeDataRqst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatSubscribeNodeDataRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatSubscribeNodeDataRqst::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::DataType BatSubscribeNodeDataRqst::type() const {
  // @@protoc_insertion_point(field_get:BatSubscribeNodeDataRqst.type)
  return static_cast< ::DataType >(type_);
}
inline void BatSubscribeNodeDataRqst::set_type(::DataType value) {
  assert(::DataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:BatSubscribeNodeDataRqst.type)
}

// required uint32 count = 2;
inline bool BatSubscribeNodeDataRqst::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatSubscribeNodeDataRqst::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatSubscribeNodeDataRqst::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatSubscribeNodeDataRqst::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 BatSubscribeNodeDataRqst::count() const {
  // @@protoc_insertion_point(field_get:BatSubscribeNodeDataRqst.count)
  return count_;
}
inline void BatSubscribeNodeDataRqst::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:BatSubscribeNodeDataRqst.count)
}

// repeated bytes node_id = 3;
inline int BatSubscribeNodeDataRqst::node_id_size() const {
  return node_id_.size();
}
inline void BatSubscribeNodeDataRqst::clear_node_id() {
  node_id_.Clear();
}
inline const ::std::string& BatSubscribeNodeDataRqst::node_id(int index) const {
  // @@protoc_insertion_point(field_get:BatSubscribeNodeDataRqst.node_id)
  return node_id_.Get(index);
}
inline ::std::string* BatSubscribeNodeDataRqst::mutable_node_id(int index) {
  // @@protoc_insertion_point(field_mutable:BatSubscribeNodeDataRqst.node_id)
  return node_id_.Mutable(index);
}
inline void BatSubscribeNodeDataRqst::set_node_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:BatSubscribeNodeDataRqst.node_id)
  node_id_.Mutable(index)->assign(value);
}
inline void BatSubscribeNodeDataRqst::set_node_id(int index, const char* value) {
  node_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BatSubscribeNodeDataRqst.node_id)
}
inline void BatSubscribeNodeDataRqst::set_node_id(int index, const void* value, size_t size) {
  node_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BatSubscribeNodeDataRqst.node_id)
}
inline ::std::string* BatSubscribeNodeDataRqst::add_node_id() {
  return node_id_.Add();
}
inline void BatSubscribeNodeDataRqst::add_node_id(const ::std::string& value) {
  node_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BatSubscribeNodeDataRqst.node_id)
}
inline void BatSubscribeNodeDataRqst::add_node_id(const char* value) {
  node_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BatSubscribeNodeDataRqst.node_id)
}
inline void BatSubscribeNodeDataRqst::add_node_id(const void* value, size_t size) {
  node_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BatSubscribeNodeDataRqst.node_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BatSubscribeNodeDataRqst::node_id() const {
  // @@protoc_insertion_point(field_list:BatSubscribeNodeDataRqst.node_id)
  return node_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BatSubscribeNodeDataRqst::mutable_node_id() {
  // @@protoc_insertion_point(field_mutable_list:BatSubscribeNodeDataRqst.node_id)
  return &node_id_;
}

// -------------------------------------------------------------------

// BatCancelNodeDataRqst

// required .DataType type = 1;
inline bool BatCancelNodeDataRqst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatCancelNodeDataRqst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatCancelNodeDataRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatCancelNodeDataRqst::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::DataType BatCancelNodeDataRqst::type() const {
  // @@protoc_insertion_point(field_get:BatCancelNodeDataRqst.type)
  return static_cast< ::DataType >(type_);
}
inline void BatCancelNodeDataRqst::set_type(::DataType value) {
  assert(::DataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:BatCancelNodeDataRqst.type)
}

// required uint32 count = 2;
inline bool BatCancelNodeDataRqst::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatCancelNodeDataRqst::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatCancelNodeDataRqst::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatCancelNodeDataRqst::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 BatCancelNodeDataRqst::count() const {
  // @@protoc_insertion_point(field_get:BatCancelNodeDataRqst.count)
  return count_;
}
inline void BatCancelNodeDataRqst::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:BatCancelNodeDataRqst.count)
}

// repeated bytes node_id = 3;
inline int BatCancelNodeDataRqst::node_id_size() const {
  return node_id_.size();
}
inline void BatCancelNodeDataRqst::clear_node_id() {
  node_id_.Clear();
}
inline const ::std::string& BatCancelNodeDataRqst::node_id(int index) const {
  // @@protoc_insertion_point(field_get:BatCancelNodeDataRqst.node_id)
  return node_id_.Get(index);
}
inline ::std::string* BatCancelNodeDataRqst::mutable_node_id(int index) {
  // @@protoc_insertion_point(field_mutable:BatCancelNodeDataRqst.node_id)
  return node_id_.Mutable(index);
}
inline void BatCancelNodeDataRqst::set_node_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:BatCancelNodeDataRqst.node_id)
  node_id_.Mutable(index)->assign(value);
}
inline void BatCancelNodeDataRqst::set_node_id(int index, const char* value) {
  node_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BatCancelNodeDataRqst.node_id)
}
inline void BatCancelNodeDataRqst::set_node_id(int index, const void* value, size_t size) {
  node_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BatCancelNodeDataRqst.node_id)
}
inline ::std::string* BatCancelNodeDataRqst::add_node_id() {
  return node_id_.Add();
}
inline void BatCancelNodeDataRqst::add_node_id(const ::std::string& value) {
  node_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BatCancelNodeDataRqst.node_id)
}
inline void BatCancelNodeDataRqst::add_node_id(const char* value) {
  node_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BatCancelNodeDataRqst.node_id)
}
inline void BatCancelNodeDataRqst::add_node_id(const void* value, size_t size) {
  node_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BatCancelNodeDataRqst.node_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BatCancelNodeDataRqst::node_id() const {
  // @@protoc_insertion_point(field_list:BatCancelNodeDataRqst.node_id)
  return node_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BatCancelNodeDataRqst::mutable_node_id() {
  // @@protoc_insertion_point(field_mutable_list:BatCancelNodeDataRqst.node_id)
  return &node_id_;
}

// -------------------------------------------------------------------

// BlackWhiteNodeRqst

// required .NodeType type = 1;
inline bool BlackWhiteNodeRqst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlackWhiteNodeRqst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlackWhiteNodeRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlackWhiteNodeRqst::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::NodeType BlackWhiteNodeRqst::type() const {
  // @@protoc_insertion_point(field_get:BlackWhiteNodeRqst.type)
  return static_cast< ::NodeType >(type_);
}
inline void BlackWhiteNodeRqst::set_type(::NodeType value) {
  assert(::NodeType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:BlackWhiteNodeRqst.type)
}

// required .BlackWhiteNodeRqst.Command cmd = 2;
inline bool BlackWhiteNodeRqst::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlackWhiteNodeRqst::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlackWhiteNodeRqst::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlackWhiteNodeRqst::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::BlackWhiteNodeRqst_Command BlackWhiteNodeRqst::cmd() const {
  // @@protoc_insertion_point(field_get:BlackWhiteNodeRqst.cmd)
  return static_cast< ::BlackWhiteNodeRqst_Command >(cmd_);
}
inline void BlackWhiteNodeRqst::set_cmd(::BlackWhiteNodeRqst_Command value) {
  assert(::BlackWhiteNodeRqst_Command_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:BlackWhiteNodeRqst.cmd)
}

// repeated string node_id = 3;
inline int BlackWhiteNodeRqst::node_id_size() const {
  return node_id_.size();
}
inline void BlackWhiteNodeRqst::clear_node_id() {
  node_id_.Clear();
}
inline const ::std::string& BlackWhiteNodeRqst::node_id(int index) const {
  // @@protoc_insertion_point(field_get:BlackWhiteNodeRqst.node_id)
  return node_id_.Get(index);
}
inline ::std::string* BlackWhiteNodeRqst::mutable_node_id(int index) {
  // @@protoc_insertion_point(field_mutable:BlackWhiteNodeRqst.node_id)
  return node_id_.Mutable(index);
}
inline void BlackWhiteNodeRqst::set_node_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:BlackWhiteNodeRqst.node_id)
  node_id_.Mutable(index)->assign(value);
}
inline void BlackWhiteNodeRqst::set_node_id(int index, const char* value) {
  node_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BlackWhiteNodeRqst.node_id)
}
inline void BlackWhiteNodeRqst::set_node_id(int index, const char* value, size_t size) {
  node_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BlackWhiteNodeRqst.node_id)
}
inline ::std::string* BlackWhiteNodeRqst::add_node_id() {
  return node_id_.Add();
}
inline void BlackWhiteNodeRqst::add_node_id(const ::std::string& value) {
  node_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BlackWhiteNodeRqst.node_id)
}
inline void BlackWhiteNodeRqst::add_node_id(const char* value) {
  node_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BlackWhiteNodeRqst.node_id)
}
inline void BlackWhiteNodeRqst::add_node_id(const char* value, size_t size) {
  node_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BlackWhiteNodeRqst.node_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BlackWhiteNodeRqst::node_id() const {
  // @@protoc_insertion_point(field_list:BlackWhiteNodeRqst.node_id)
  return node_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BlackWhiteNodeRqst::mutable_node_id() {
  // @@protoc_insertion_point(field_mutable_list:BlackWhiteNodeRqst.node_id)
  return &node_id_;
}

// -------------------------------------------------------------------

// GetBlackWhiteRqst

// required .NodeType type = 1;
inline bool GetBlackWhiteRqst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBlackWhiteRqst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBlackWhiteRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBlackWhiteRqst::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::NodeType GetBlackWhiteRqst::type() const {
  // @@protoc_insertion_point(field_get:GetBlackWhiteRqst.type)
  return static_cast< ::NodeType >(type_);
}
inline void GetBlackWhiteRqst::set_type(::NodeType value) {
  assert(::NodeType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:GetBlackWhiteRqst.type)
}

// -------------------------------------------------------------------

// GetBlackWhiteRsps

// required uint32 count = 1;
inline bool GetBlackWhiteRsps::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBlackWhiteRsps::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBlackWhiteRsps::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBlackWhiteRsps::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 GetBlackWhiteRsps::count() const {
  // @@protoc_insertion_point(field_get:GetBlackWhiteRsps.count)
  return count_;
}
inline void GetBlackWhiteRsps::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:GetBlackWhiteRsps.count)
}

// repeated string node_id = 2;
inline int GetBlackWhiteRsps::node_id_size() const {
  return node_id_.size();
}
inline void GetBlackWhiteRsps::clear_node_id() {
  node_id_.Clear();
}
inline const ::std::string& GetBlackWhiteRsps::node_id(int index) const {
  // @@protoc_insertion_point(field_get:GetBlackWhiteRsps.node_id)
  return node_id_.Get(index);
}
inline ::std::string* GetBlackWhiteRsps::mutable_node_id(int index) {
  // @@protoc_insertion_point(field_mutable:GetBlackWhiteRsps.node_id)
  return node_id_.Mutable(index);
}
inline void GetBlackWhiteRsps::set_node_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:GetBlackWhiteRsps.node_id)
  node_id_.Mutable(index)->assign(value);
}
inline void GetBlackWhiteRsps::set_node_id(int index, const char* value) {
  node_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GetBlackWhiteRsps.node_id)
}
inline void GetBlackWhiteRsps::set_node_id(int index, const char* value, size_t size) {
  node_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetBlackWhiteRsps.node_id)
}
inline ::std::string* GetBlackWhiteRsps::add_node_id() {
  return node_id_.Add();
}
inline void GetBlackWhiteRsps::add_node_id(const ::std::string& value) {
  node_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:GetBlackWhiteRsps.node_id)
}
inline void GetBlackWhiteRsps::add_node_id(const char* value) {
  node_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GetBlackWhiteRsps.node_id)
}
inline void GetBlackWhiteRsps::add_node_id(const char* value, size_t size) {
  node_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GetBlackWhiteRsps.node_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetBlackWhiteRsps::node_id() const {
  // @@protoc_insertion_point(field_list:GetBlackWhiteRsps.node_id)
  return node_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetBlackWhiteRsps::mutable_node_id() {
  // @@protoc_insertion_point(field_mutable_list:GetBlackWhiteRsps.node_id)
  return &node_id_;
}

// -------------------------------------------------------------------

// DownloadFirmwareRqst

// required string node_id = 1;
inline bool DownloadFirmwareRqst::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownloadFirmwareRqst::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownloadFirmwareRqst::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownloadFirmwareRqst::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& DownloadFirmwareRqst::node_id() const {
  // @@protoc_insertion_point(field_get:DownloadFirmwareRqst.node_id)
  return *node_id_;
}
inline void DownloadFirmwareRqst::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:DownloadFirmwareRqst.node_id)
}
inline void DownloadFirmwareRqst::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:DownloadFirmwareRqst.node_id)
}
inline void DownloadFirmwareRqst::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DownloadFirmwareRqst.node_id)
}
inline ::std::string* DownloadFirmwareRqst::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DownloadFirmwareRqst.node_id)
  return node_id_;
}
inline ::std::string* DownloadFirmwareRqst::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DownloadFirmwareRqst::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DownloadFirmwareRqst.node_id)
}

// required string url = 2;
inline bool DownloadFirmwareRqst::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DownloadFirmwareRqst::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DownloadFirmwareRqst::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DownloadFirmwareRqst::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& DownloadFirmwareRqst::url() const {
  // @@protoc_insertion_point(field_get:DownloadFirmwareRqst.url)
  return *url_;
}
inline void DownloadFirmwareRqst::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:DownloadFirmwareRqst.url)
}
inline void DownloadFirmwareRqst::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:DownloadFirmwareRqst.url)
}
inline void DownloadFirmwareRqst::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DownloadFirmwareRqst.url)
}
inline ::std::string* DownloadFirmwareRqst::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DownloadFirmwareRqst.url)
  return url_;
}
inline ::std::string* DownloadFirmwareRqst::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DownloadFirmwareRqst::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DownloadFirmwareRqst.url)
}

// -------------------------------------------------------------------

// DownloadFirmwareRsps

// required .ReceiveStatus receive_status = 1;
inline bool DownloadFirmwareRsps::has_receive_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownloadFirmwareRsps::set_has_receive_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownloadFirmwareRsps::clear_has_receive_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownloadFirmwareRsps::clear_receive_status() {
  receive_status_ = 1;
  clear_has_receive_status();
}
inline ::ReceiveStatus DownloadFirmwareRsps::receive_status() const {
  // @@protoc_insertion_point(field_get:DownloadFirmwareRsps.receive_status)
  return static_cast< ::ReceiveStatus >(receive_status_);
}
inline void DownloadFirmwareRsps::set_receive_status(::ReceiveStatus value) {
  assert(::ReceiveStatus_IsValid(value));
  set_has_receive_status();
  receive_status_ = value;
  // @@protoc_insertion_point(field_set:DownloadFirmwareRsps.receive_status)
}

// -------------------------------------------------------------------

// DownloadFirmwareNtf

// required uint32 seq = 1;
inline bool DownloadFirmwareNtf::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownloadFirmwareNtf::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownloadFirmwareNtf::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownloadFirmwareNtf::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 DownloadFirmwareNtf::seq() const {
  // @@protoc_insertion_point(field_get:DownloadFirmwareNtf.seq)
  return seq_;
}
inline void DownloadFirmwareNtf::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:DownloadFirmwareNtf.seq)
}

// required .ExecuteStatus execute_status = 2;
inline bool DownloadFirmwareNtf::has_execute_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DownloadFirmwareNtf::set_has_execute_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DownloadFirmwareNtf::clear_has_execute_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DownloadFirmwareNtf::clear_execute_status() {
  execute_status_ = 1;
  clear_has_execute_status();
}
inline ::ExecuteStatus DownloadFirmwareNtf::execute_status() const {
  // @@protoc_insertion_point(field_get:DownloadFirmwareNtf.execute_status)
  return static_cast< ::ExecuteStatus >(execute_status_);
}
inline void DownloadFirmwareNtf::set_execute_status(::ExecuteStatus value) {
  assert(::ExecuteStatus_IsValid(value));
  set_has_execute_status();
  execute_status_ = value;
  // @@protoc_insertion_point(field_set:DownloadFirmwareNtf.execute_status)
}

// -------------------------------------------------------------------

// UpgradeModuleRqst

// required string module_name = 1;
inline bool UpgradeModuleRqst::has_module_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeModuleRqst::set_has_module_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeModuleRqst::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeModuleRqst::clear_module_name() {
  if (module_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_name_->clear();
  }
  clear_has_module_name();
}
inline const ::std::string& UpgradeModuleRqst::module_name() const {
  // @@protoc_insertion_point(field_get:UpgradeModuleRqst.module_name)
  return *module_name_;
}
inline void UpgradeModuleRqst::set_module_name(const ::std::string& value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
  // @@protoc_insertion_point(field_set:UpgradeModuleRqst.module_name)
}
inline void UpgradeModuleRqst::set_module_name(const char* value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:UpgradeModuleRqst.module_name)
}
inline void UpgradeModuleRqst::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UpgradeModuleRqst.module_name)
}
inline ::std::string* UpgradeModuleRqst::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UpgradeModuleRqst.module_name)
  return module_name_;
}
inline ::std::string* UpgradeModuleRqst::release_module_name() {
  clear_has_module_name();
  if (module_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = module_name_;
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpgradeModuleRqst::set_allocated_module_name(::std::string* module_name) {
  if (module_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete module_name_;
  }
  if (module_name) {
    set_has_module_name();
    module_name_ = module_name;
  } else {
    clear_has_module_name();
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UpgradeModuleRqst.module_name)
}

// -------------------------------------------------------------------

// UpgradeModuleRsps

// required .ReceiveStatus receive_status = 1;
inline bool UpgradeModuleRsps::has_receive_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeModuleRsps::set_has_receive_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeModuleRsps::clear_has_receive_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeModuleRsps::clear_receive_status() {
  receive_status_ = 1;
  clear_has_receive_status();
}
inline ::ReceiveStatus UpgradeModuleRsps::receive_status() const {
  // @@protoc_insertion_point(field_get:UpgradeModuleRsps.receive_status)
  return static_cast< ::ReceiveStatus >(receive_status_);
}
inline void UpgradeModuleRsps::set_receive_status(::ReceiveStatus value) {
  assert(::ReceiveStatus_IsValid(value));
  set_has_receive_status();
  receive_status_ = value;
  // @@protoc_insertion_point(field_set:UpgradeModuleRsps.receive_status)
}

// -------------------------------------------------------------------

// UpgradeModuleNtf

// required uint32 seq = 1;
inline bool UpgradeModuleNtf::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeModuleNtf::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeModuleNtf::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeModuleNtf::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 UpgradeModuleNtf::seq() const {
  // @@protoc_insertion_point(field_get:UpgradeModuleNtf.seq)
  return seq_;
}
inline void UpgradeModuleNtf::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:UpgradeModuleNtf.seq)
}

// required .ExecuteStatus execute_status = 2;
inline bool UpgradeModuleNtf::has_execute_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeModuleNtf::set_has_execute_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeModuleNtf::clear_has_execute_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeModuleNtf::clear_execute_status() {
  execute_status_ = 1;
  clear_has_execute_status();
}
inline ::ExecuteStatus UpgradeModuleNtf::execute_status() const {
  // @@protoc_insertion_point(field_get:UpgradeModuleNtf.execute_status)
  return static_cast< ::ExecuteStatus >(execute_status_);
}
inline void UpgradeModuleNtf::set_execute_status(::ExecuteStatus value) {
  assert(::ExecuteStatus_IsValid(value));
  set_has_execute_status();
  execute_status_ = value;
  // @@protoc_insertion_point(field_set:UpgradeModuleNtf.execute_status)
}

// -------------------------------------------------------------------

// TerminalPort

// required uint32 port_num = 1;
inline bool TerminalPort::has_port_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TerminalPort::set_has_port_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TerminalPort::clear_has_port_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TerminalPort::clear_port_num() {
  port_num_ = 0u;
  clear_has_port_num();
}
inline ::google::protobuf::uint32 TerminalPort::port_num() const {
  // @@protoc_insertion_point(field_get:TerminalPort.port_num)
  return port_num_;
}
inline void TerminalPort::set_port_num(::google::protobuf::uint32 value) {
  set_has_port_num();
  port_num_ = value;
  // @@protoc_insertion_point(field_set:TerminalPort.port_num)
}

// required uint32 cmd_type = 2;
inline bool TerminalPort::has_cmd_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TerminalPort::set_has_cmd_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TerminalPort::clear_has_cmd_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TerminalPort::clear_cmd_type() {
  cmd_type_ = 0u;
  clear_has_cmd_type();
}
inline ::google::protobuf::uint32 TerminalPort::cmd_type() const {
  // @@protoc_insertion_point(field_get:TerminalPort.cmd_type)
  return cmd_type_;
}
inline void TerminalPort::set_cmd_type(::google::protobuf::uint32 value) {
  set_has_cmd_type();
  cmd_type_ = value;
  // @@protoc_insertion_point(field_set:TerminalPort.cmd_type)
}

// -------------------------------------------------------------------

// TerminalStatus

// required uint32 port_num = 1;
inline bool TerminalStatus::has_port_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TerminalStatus::set_has_port_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TerminalStatus::clear_has_port_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TerminalStatus::clear_port_num() {
  port_num_ = 0u;
  clear_has_port_num();
}
inline ::google::protobuf::uint32 TerminalStatus::port_num() const {
  // @@protoc_insertion_point(field_get:TerminalStatus.port_num)
  return port_num_;
}
inline void TerminalStatus::set_port_num(::google::protobuf::uint32 value) {
  set_has_port_num();
  port_num_ = value;
  // @@protoc_insertion_point(field_set:TerminalStatus.port_num)
}

// required uint32 cmd_type = 2;
inline bool TerminalStatus::has_cmd_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TerminalStatus::set_has_cmd_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TerminalStatus::clear_has_cmd_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TerminalStatus::clear_cmd_type() {
  cmd_type_ = 0u;
  clear_has_cmd_type();
}
inline ::google::protobuf::uint32 TerminalStatus::cmd_type() const {
  // @@protoc_insertion_point(field_get:TerminalStatus.cmd_type)
  return cmd_type_;
}
inline void TerminalStatus::set_cmd_type(::google::protobuf::uint32 value) {
  set_has_cmd_type();
  cmd_type_ = value;
  // @@protoc_insertion_point(field_set:TerminalStatus.cmd_type)
}

// required bytes data = 3;
inline bool TerminalStatus::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TerminalStatus::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TerminalStatus::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TerminalStatus::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TerminalStatus::data() const {
  // @@protoc_insertion_point(field_get:TerminalStatus.data)
  return *data_;
}
inline void TerminalStatus::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:TerminalStatus.data)
}
inline void TerminalStatus::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:TerminalStatus.data)
}
inline void TerminalStatus::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TerminalStatus.data)
}
inline ::std::string* TerminalStatus::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TerminalStatus.data)
  return data_;
}
inline ::std::string* TerminalStatus::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TerminalStatus::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TerminalStatus.data)
}

// -------------------------------------------------------------------

// GetTerminalStatusRqst

// required string node_id = 1;
inline bool GetTerminalStatusRqst::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTerminalStatusRqst::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTerminalStatusRqst::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTerminalStatusRqst::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& GetTerminalStatusRqst::node_id() const {
  // @@protoc_insertion_point(field_get:GetTerminalStatusRqst.node_id)
  return *node_id_;
}
inline void GetTerminalStatusRqst::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:GetTerminalStatusRqst.node_id)
}
inline void GetTerminalStatusRqst::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetTerminalStatusRqst.node_id)
}
inline void GetTerminalStatusRqst::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetTerminalStatusRqst.node_id)
}
inline ::std::string* GetTerminalStatusRqst::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetTerminalStatusRqst.node_id)
  return node_id_;
}
inline ::std::string* GetTerminalStatusRqst::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTerminalStatusRqst::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetTerminalStatusRqst.node_id)
}

// repeated .TerminalPort port = 2;
inline int GetTerminalStatusRqst::port_size() const {
  return port_.size();
}
inline void GetTerminalStatusRqst::clear_port() {
  port_.Clear();
}
inline const ::TerminalPort& GetTerminalStatusRqst::port(int index) const {
  // @@protoc_insertion_point(field_get:GetTerminalStatusRqst.port)
  return port_.Get(index);
}
inline ::TerminalPort* GetTerminalStatusRqst::mutable_port(int index) {
  // @@protoc_insertion_point(field_mutable:GetTerminalStatusRqst.port)
  return port_.Mutable(index);
}
inline ::TerminalPort* GetTerminalStatusRqst::add_port() {
  // @@protoc_insertion_point(field_add:GetTerminalStatusRqst.port)
  return port_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TerminalPort >&
GetTerminalStatusRqst::port() const {
  // @@protoc_insertion_point(field_list:GetTerminalStatusRqst.port)
  return port_;
}
inline ::google::protobuf::RepeatedPtrField< ::TerminalPort >*
GetTerminalStatusRqst::mutable_port() {
  // @@protoc_insertion_point(field_mutable_list:GetTerminalStatusRqst.port)
  return &port_;
}

// -------------------------------------------------------------------

// GetTerminalStatusRsps

// required string node_id = 1;
inline bool GetTerminalStatusRsps::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTerminalStatusRsps::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTerminalStatusRsps::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTerminalStatusRsps::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& GetTerminalStatusRsps::node_id() const {
  // @@protoc_insertion_point(field_get:GetTerminalStatusRsps.node_id)
  return *node_id_;
}
inline void GetTerminalStatusRsps::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:GetTerminalStatusRsps.node_id)
}
inline void GetTerminalStatusRsps::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetTerminalStatusRsps.node_id)
}
inline void GetTerminalStatusRsps::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetTerminalStatusRsps.node_id)
}
inline ::std::string* GetTerminalStatusRsps::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetTerminalStatusRsps.node_id)
  return node_id_;
}
inline ::std::string* GetTerminalStatusRsps::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTerminalStatusRsps::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetTerminalStatusRsps.node_id)
}

// repeated .TerminalStatus status = 2;
inline int GetTerminalStatusRsps::status_size() const {
  return status_.size();
}
inline void GetTerminalStatusRsps::clear_status() {
  status_.Clear();
}
inline const ::TerminalStatus& GetTerminalStatusRsps::status(int index) const {
  // @@protoc_insertion_point(field_get:GetTerminalStatusRsps.status)
  return status_.Get(index);
}
inline ::TerminalStatus* GetTerminalStatusRsps::mutable_status(int index) {
  // @@protoc_insertion_point(field_mutable:GetTerminalStatusRsps.status)
  return status_.Mutable(index);
}
inline ::TerminalStatus* GetTerminalStatusRsps::add_status() {
  // @@protoc_insertion_point(field_add:GetTerminalStatusRsps.status)
  return status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TerminalStatus >&
GetTerminalStatusRsps::status() const {
  // @@protoc_insertion_point(field_list:GetTerminalStatusRsps.status)
  return status_;
}
inline ::google::protobuf::RepeatedPtrField< ::TerminalStatus >*
GetTerminalStatusRsps::mutable_status() {
  // @@protoc_insertion_point(field_mutable_list:GetTerminalStatusRsps.status)
  return &status_;
}

// -------------------------------------------------------------------

// TerminalCmd

// required uint32 port_num = 1;
inline bool TerminalCmd::has_port_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TerminalCmd::set_has_port_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TerminalCmd::clear_has_port_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TerminalCmd::clear_port_num() {
  port_num_ = 0u;
  clear_has_port_num();
}
inline ::google::protobuf::uint32 TerminalCmd::port_num() const {
  // @@protoc_insertion_point(field_get:TerminalCmd.port_num)
  return port_num_;
}
inline void TerminalCmd::set_port_num(::google::protobuf::uint32 value) {
  set_has_port_num();
  port_num_ = value;
  // @@protoc_insertion_point(field_set:TerminalCmd.port_num)
}

// required uint32 cmd_type = 2;
inline bool TerminalCmd::has_cmd_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TerminalCmd::set_has_cmd_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TerminalCmd::clear_has_cmd_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TerminalCmd::clear_cmd_type() {
  cmd_type_ = 0u;
  clear_has_cmd_type();
}
inline ::google::protobuf::uint32 TerminalCmd::cmd_type() const {
  // @@protoc_insertion_point(field_get:TerminalCmd.cmd_type)
  return cmd_type_;
}
inline void TerminalCmd::set_cmd_type(::google::protobuf::uint32 value) {
  set_has_cmd_type();
  cmd_type_ = value;
  // @@protoc_insertion_point(field_set:TerminalCmd.cmd_type)
}

// required bytes data = 3;
inline bool TerminalCmd::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TerminalCmd::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TerminalCmd::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TerminalCmd::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TerminalCmd::data() const {
  // @@protoc_insertion_point(field_get:TerminalCmd.data)
  return *data_;
}
inline void TerminalCmd::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:TerminalCmd.data)
}
inline void TerminalCmd::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:TerminalCmd.data)
}
inline void TerminalCmd::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TerminalCmd.data)
}
inline ::std::string* TerminalCmd::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TerminalCmd.data)
  return data_;
}
inline ::std::string* TerminalCmd::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TerminalCmd::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TerminalCmd.data)
}

// -------------------------------------------------------------------

// SetTerminalCtrlCmdRqst

// required string node_id = 1;
inline bool SetTerminalCtrlCmdRqst::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetTerminalCtrlCmdRqst::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetTerminalCtrlCmdRqst::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetTerminalCtrlCmdRqst::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& SetTerminalCtrlCmdRqst::node_id() const {
  // @@protoc_insertion_point(field_get:SetTerminalCtrlCmdRqst.node_id)
  return *node_id_;
}
inline void SetTerminalCtrlCmdRqst::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set:SetTerminalCtrlCmdRqst.node_id)
}
inline void SetTerminalCtrlCmdRqst::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:SetTerminalCtrlCmdRqst.node_id)
}
inline void SetTerminalCtrlCmdRqst::set_node_id(const char* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetTerminalCtrlCmdRqst.node_id)
}
inline ::std::string* SetTerminalCtrlCmdRqst::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SetTerminalCtrlCmdRqst.node_id)
  return node_id_;
}
inline ::std::string* SetTerminalCtrlCmdRqst::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetTerminalCtrlCmdRqst::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SetTerminalCtrlCmdRqst.node_id)
}

// repeated .TerminalCmd cmd_data = 2;
inline int SetTerminalCtrlCmdRqst::cmd_data_size() const {
  return cmd_data_.size();
}
inline void SetTerminalCtrlCmdRqst::clear_cmd_data() {
  cmd_data_.Clear();
}
inline const ::TerminalCmd& SetTerminalCtrlCmdRqst::cmd_data(int index) const {
  // @@protoc_insertion_point(field_get:SetTerminalCtrlCmdRqst.cmd_data)
  return cmd_data_.Get(index);
}
inline ::TerminalCmd* SetTerminalCtrlCmdRqst::mutable_cmd_data(int index) {
  // @@protoc_insertion_point(field_mutable:SetTerminalCtrlCmdRqst.cmd_data)
  return cmd_data_.Mutable(index);
}
inline ::TerminalCmd* SetTerminalCtrlCmdRqst::add_cmd_data() {
  // @@protoc_insertion_point(field_add:SetTerminalCtrlCmdRqst.cmd_data)
  return cmd_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TerminalCmd >&
SetTerminalCtrlCmdRqst::cmd_data() const {
  // @@protoc_insertion_point(field_list:SetTerminalCtrlCmdRqst.cmd_data)
  return cmd_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::TerminalCmd >*
SetTerminalCtrlCmdRqst::mutable_cmd_data() {
  // @@protoc_insertion_point(field_mutable_list:SetTerminalCtrlCmdRqst.cmd_data)
  return &cmd_data_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Response_Error> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Response_Error>() {
  return ::Response_Error_descriptor();
}
template <> struct is_proto_enum< ::SubscribeNotificationNtf_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SubscribeNotificationNtf_MessageType>() {
  return ::SubscribeNotificationNtf_MessageType_descriptor();
}
template <> struct is_proto_enum< ::SetCommandToNodeRqst_Command> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SetCommandToNodeRqst_Command>() {
  return ::SetCommandToNodeRqst_Command_descriptor();
}
template <> struct is_proto_enum< ::GetNodeSettingsRqst_Command> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GetNodeSettingsRqst_Command>() {
  return ::GetNodeSettingsRqst_Command_descriptor();
}
template <> struct is_proto_enum< ::BlackWhiteNodeRqst_Command> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BlackWhiteNodeRqst_Command>() {
  return ::BlackWhiteNodeRqst_Command_descriptor();
}
template <> struct is_proto_enum< ::Command> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Command>() {
  return ::Command_descriptor();
}
template <> struct is_proto_enum< ::Encrypt> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Encrypt>() {
  return ::Encrypt_descriptor();
}
template <> struct is_proto_enum< ::DeviceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DeviceType>() {
  return ::DeviceType_descriptor();
}
template <> struct is_proto_enum< ::DeviceModel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DeviceModel>() {
  return ::DeviceModel_descriptor();
}
template <> struct is_proto_enum< ::ConfigName> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ConfigName>() {
  return ::ConfigName_descriptor();
}
template <> struct is_proto_enum< ::Enable> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Enable>() {
  return ::Enable_descriptor();
}
template <> struct is_proto_enum< ::NodeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NodeType>() {
  return ::NodeType_descriptor();
}
template <> struct is_proto_enum< ::DataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataType>() {
  return ::DataType_descriptor();
}
template <> struct is_proto_enum< ::LogType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LogType>() {
  return ::LogType_descriptor();
}
template <> struct is_proto_enum< ::ReceiveStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ReceiveStatus>() {
  return ::ReceiveStatus_descriptor();
}
template <> struct is_proto_enum< ::ExecuteStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExecuteStatus>() {
  return ::ExecuteStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_nwpb_2eproto__INCLUDED
